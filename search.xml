<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring</title>
    <url>/2019/11/30/Spring/</url>
    <content><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="第1章-Spring概述"><a href="#第1章-Spring概述" class="headerlink" title="第1章 Spring概述"></a>第1章 Spring概述</h2><h3 id="1-1-Spring概述"><a href="#1-1-Spring概述" class="headerlink" title="1.1 Spring概述"></a>1.1 Spring概述</h3><ol>
<li>Spring 是一个开源框架。</li>
<li>Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能。</li>
<li>Spring 是一个 IOC(DI) 和 AOP 容器框架。</li>
</ol>
<p>具体描述 Spring:</p>
<ol>
<li>轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API</li>
<li>依赖注入(DI — dependency injection、IOC)</li>
<li>面向切面编程(AOP — aspect oriented programming)</li>
<li>容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期</li>
<li>框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象</li>
<li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）</li>
</ol>
<h3 id="1-2-Spring模块"><a href="#1-2-Spring模块" class="headerlink" title="1.2  Spring模块"></a>1.2  Spring模块</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574990699897.png" alt="1574990699897"></p>
<p>Test:    Spring的单元测试模块。</p>
<p>Core Container:    核心容器（IoC),黑色代表这部分的功能由哪些jar包组成,要使用这个部分的完整功能，这些jar包都需要导入。</p>
<p>AOP+Aspects:    面向切面编程。</p>
<p>Data Access/Integration:    Spring数据访问模块/集成</p>
<p>Web:    Spring开发web应用的模块。</p>
<h2 id="第2章-IOC容器和Bean的配置"><a href="#第2章-IOC容器和Bean的配置" class="headerlink" title="第2章 IOC容器和Bean的配置"></a>第2章 IOC容器和Bean的配置</h2><h3 id="2-1-IOC和DI"><a href="#2-1-IOC和DI" class="headerlink" title="2.1 IOC和DI"></a>2.1 IOC和DI</h3><h4 id="2-1-1-IOC-Inversion-of-Control"><a href="#2-1-1-IOC-Inversion-of-Control" class="headerlink" title="2.1.1 IOC(Inversion of Control)"></a>2.1.1 IOC(Inversion of Control)</h4><p>​    控制反转，所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</p>
<ol>
<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>
<li><strong>控制什么</strong>：控制对象。</li>
<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>
</ol>
<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。类似容器（婚介所):主动获取变为被动接受。</p>
<h4 id="2-1-2-DI-Dependency-Injection"><a href="#2-1-2-DI-Dependency-Injection" class="headerlink" title="2.1.2 DI(Dependency Injection)"></a>2.1.2 DI(Dependency Injection)</h4><p>​    IOC 的另一种表述方式：依赖注入,容器动态地将某个依赖关系注入到组件之中，换句话说容器指定哪个组件运行的时候,需要另一个组件。</p>
<h4 id="2-1-3-关系"><a href="#2-1-3-关系" class="headerlink" title="2.1.3 关系"></a>2.1.3 关系</h4><p>​    其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<h4 id="2-1-4-IOC-容器在-Spring-中的实现"><a href="#2-1-4-IOC-容器在-Spring-中的实现" class="headerlink" title="2.1.4  IOC 容器在 Spring 中的实现"></a>2.1.4  <strong>IOC</strong> <strong>容器在</strong> <strong>Spring</strong> 中的实现</h4><p>在通过 IOC 容器读取 Bean 的实例之前，需要先将 IOC 容器本身实例化。 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用</p>
<p>Spring 提供了 IOC 容器的两种实现方式</p>
<h5 id="①-BeanFactory"><a href="#①-BeanFactory" class="headerlink" title="① BeanFactory"></a>① BeanFactory</h5><p>IOC 容器的基本实现，是 Spring 内部的基础设施，是面向 Spring 本身的，不是提供给开发人员使用的。 </p>
<h5 id="②-ApplicationContext"><a href="#②-ApplicationContext" class="headerlink" title="② ApplicationContext"></a>② ApplicationContext</h5><p>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的 使 用 者 ， 几 乎 所 有 场 合 都 使 用 ApplicationContext 而 不 是 底 层 的 BeanFactory 。 </p>
<p>ApplicationContext 的主要实现类：<br>1.ClassPathXmlApplicationContext：从类路径(ClassPath)下加载配置文件。<br>2.FileSystemXmlApplicationContext:  从文件系统中加载配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext =<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力。</p>
<p>AanpplicationContext 在初始化上下文时就实例化所有单例的 Bean。<br>WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作。</p>
<p>​    </p>
<h3 id="2-2-从IOC容器中获取Bean"><a href="#2-2-从IOC容器中获取Bean" class="headerlink" title="2.2 从IOC容器中获取Bean"></a>2.2 从IOC容器中获取Bean</h3><p>​    从 IOC 容器中获取 bean 时，除了通过 id 值获取，还可以通过 bean 的类型获取。但如 果同一个类型的 bean 在 XML 文件中配置了多个，则获取时会抛出异常，所以同一个类型的 bean 在容器中必须是唯一的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = applicationContext.getBean(User.class);</span><br></pre></td></tr></table></figure>

<p>或者可以使用另外一个重载的方法，同时指定 bean 的 id 值和类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = applicationContext.getBean(<span class="string">"user"</span>,User.class);</span><br></pre></td></tr></table></figure>

<p>注:</p>
<p>​    同一个组件在容器中是单实例的,容器中对象的创建在容器创建完成的时候就已经创建好了。</p>
<h3 id="2-3-依赖注入的方式-基于xml配置"><a href="#2-3-依赖注入的方式-基于xml配置" class="headerlink" title="2.3 依赖注入的方式(基于xml配置)"></a>2.3 依赖注入的方式(基于xml配置)</h3><h4 id="2-3-1-属性注入"><a href="#2-3-1-属性注入" class="headerlink" title="2.3.1 属性注入"></a>2.3.1 属性注入</h4><p>​    属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象。使用 &lt;property&gt; 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 &lt;value&gt; 子节点指定属性值 。属性注入是实际应用中最常用的注入方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类User</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	applicationContext.xml</span></span><br><span class="line"><span class="comment">	配置Bean</span></span><br><span class="line"><span class="comment">	class:bean的全类名,通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器</span></span><br><span class="line"><span class="comment">	id:标识容器中的Bean,在容器中必须是唯一的,若id没有指定,Spring自动将权限定性类名作为Bean的名字。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	property有三个参数:</span></span><br><span class="line"><span class="comment">	name:属性名,在实体bean中必须有对应的setter方法,否则报错。</span></span><br><span class="line"><span class="comment">	value:可以赋基本数据类型与String。</span></span><br><span class="line"><span class="comment">	ref:引用外部的bean。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"yinyuanyang"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注:</p>
<p>​    javaBean的属性名由setter方法(set去掉后面首字母小写)决定。</p>
<h4 id="2-3-2-构造器注入"><a href="#2-3-2-构造器注入" class="headerlink" title="2.3.2 构造器注入"></a>2.3.2 构造器注入</h4><p>​    通过构造方法注入Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。不用为属性设置setter方法，但是需要有参构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类User</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	applicationContext.xml</span></span><br><span class="line"><span class="comment">	constructor-arg有5个参数:</span></span><br><span class="line"><span class="comment">	name:参数名</span></span><br><span class="line"><span class="comment">	value:可以赋基本数据类型与String</span></span><br><span class="line"><span class="comment">	index:参数的索引,从0开始</span></span><br><span class="line"><span class="comment">	ref:引用外部的bean</span></span><br><span class="line"><span class="comment">	type:类型(区分关键字与封装类 int Integer java.lang.String)  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"Yin"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-工厂方法注入"><a href="#2-3-3-工厂方法注入" class="headerlink" title="2.3.3 工厂方法注入"></a>2.3.3 工厂方法注入</h4><p>   不常用</p>
<h4 id="2-3-4-XML-配置里的-Bean-自动装配（仅限与对自定义类型的属性"><a href="#2-3-4-XML-配置里的-Bean-自动装配（仅限与对自定义类型的属性" class="headerlink" title="2.3.4 XML 配置里的 Bean 自动装配（仅限与对自定义类型的属性)"></a>2.3.4 XML 配置里的 Bean 自动装配（仅限与对自定义类型的属性)</h4><p>​    Spring IOC 容器可以自动装配 Bean. 需要做的仅仅是在&lt;bean&gt; 的 autowire 属性里指定自动装配的模式,autowire=”defalut/no”,不自动装配。</p>
<h5 id="1-byType-根据类型自动装配"><a href="#1-byType-根据类型自动装配" class="headerlink" title="1.byType(根据类型自动装配)"></a>1.byType(根据类型自动装配)</h5><p>​    applicationContext.getBean(Dept.class);</p>
<p>​    若 IOC 容器中有多个与目标 Bean 类型一致的 Bean. 在这种情况下, Spring 将无法判定哪个 Bean 最合适该属性, 所以不能执行自动装配.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Emp"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptno"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dname"</span>  <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果</span></span><br><span class="line"><span class="comment"> Emp [empno=null, ename=null, sal=0.0, dept=Dept [deptno=11, dname=root] ]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果有多个与目标 Bean 类型一致的 Bean:</span><br><span class="line">报错信息如下：</span><br><span class="line">No qualifying bean of type [com.yyy.entity.Dept] is defined: expected single matching bean but found <span class="number">2</span>: dept1,dept2</span><br></pre></td></tr></table></figure>



<h5 id="2-byName-根据名称自动装配"><a href="#2-byName-根据名称自动装配" class="headerlink" title="2.byName(根据名称自动装配)"></a>2.byName(根据名称自动装配)</h5><p>​    applicationContext.getBean(“dept”);</p>
<p>​    必须将目标 Bean 的名称和属性名设置的完全相同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Emp"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--按照属性名(dept..)作为id去容器中找到对应id的Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptno"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dname"</span>  <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>d</span><br><span class="line"><span class="comment">&lt;!-- 结果： </span></span><br><span class="line"><span class="comment">	Emp [empno=null, ename=null, sal=0.0, dept=Dept [deptno=11, dname=root] ]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果目标 Bean 的名称和属性名设置的不相同,找不到装配Null。</span><br><span class="line">Emp [empno=<span class="keyword">null</span>, ename=<span class="keyword">null</span>, sal=<span class="number">0.0</span>, dept=<span class="keyword">null</span>]</span><br></pre></td></tr></table></figure>



<h5 id="3-constructor-通过构造器自动装配"><a href="#3-constructor-通过构造器自动装配" class="headerlink" title="3.constructor(通过构造器自动装配)"></a>3.constructor(通过构造器自动装配)</h5><p>​    当 Bean 中存在多个构造器时, 此种自动装配方式将会很复杂,<strong>不推荐使用。</strong></p>
<p>​    流程:</p>
<ol>
<li>先按照有参构造器参数的类型进行装配(成功就赋值),没有就直接为组件装配Null。</li>
<li>如果按照类型找到了多个,参数的名作为id继续匹配；找到就装配,没有就Null。</li>
<li>不会报错。</li>
</ol>
<h4 id="2-3-5-泛型依赖注入"><a href="#2-3-5-泛型依赖注入" class="headerlink" title="2.3.5 泛型依赖注入"></a>2.3.5 泛型依赖注入</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191202144938189.png" alt="image-20191202144938189"></p>
<h3 id="2-4-p命名空间"><a href="#2-4-p命名空间" class="headerlink" title="2.4 p命名空间"></a>2.4 p命名空间</h3><p>​    为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过 &lt;bean&gt; 元素属性的方式配置 Bean 的属性。使用 p 命名空间后，基于 XML 的配置方式将进一步简化。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span> <span class="attr">p:userId</span>=<span class="string">"1"</span> <span class="attr">p:userName</span>=<span class="string">"spring"</span> <span class="attr">p:password</span>=<span class="string">"123456"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5-通过注解配置Bean"><a href="#2-5-通过注解配置Bean" class="headerlink" title="2.5 通过注解配置Bean"></a>2.5 通过注解配置Bean</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><p>​    相对于 XML 方式而言，通过注解的方式配置 bean 更加简洁和优雅，而且和 MVC 组件化开发的理念十分契合，是开发中常用的使用方式。</p>
<h4 id="2-5-2-使用注解标识组件"><a href="#2-5-2-使用注解标识组件" class="headerlink" title="2.5.2 使用注解标识组件"></a>2.5.2 使用注解标识组件</h4><h5 id="1-普通组件：-Component"><a href="#1-普通组件：-Component" class="headerlink" title="1.普通组件：@Component"></a>1.普通组件：@Component</h5><p>标识一个受 Spring IOC 容器管理的组件,当不知道一些类归到哪个层时使用,但是不建议。</p>
<h5 id="2-持久化层组件：-Repository"><a href="#2-持久化层组件：-Repository" class="headerlink" title="2.持久化层组件：@Repository"></a>2.持久化层组件：@Repository</h5><p>标识一个受 Spring IOC 容器管理的持久化层组件。 </p>
<h5 id="3-业务逻辑层组件：-Service"><a href="#3-业务逻辑层组件：-Service" class="headerlink" title="3.业务逻辑层组件：@Service"></a>3.业务逻辑层组件：@Service</h5><p>标识一个受 Spring IOC 容器管理的业务逻辑层组件。 </p>
<h5 id="4-表述层控制器组件：-Controller"><a href="#4-表述层控制器组件：-Controller" class="headerlink" title="4.表述层控制器组件：@Controller"></a>4.表述层控制器组件：@Controller</h5><p>标识一个受 Spring IOC 容器管理的表述层控制器组件。</p>
<h5 id="5-组件命名规则"><a href="#5-组件命名规则" class="headerlink" title="5.组件命名规则"></a>5.组件命名规则</h5><p>​    ①默认情况：使用组件的<strong>简单类名首字母小写</strong>后得到的字符串作为 bean 的 id 。</p>
<p>​    ②使用组件注解的 value 属性指定 bean 的 id 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//id默认类名首字母小写</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BookDaoImpl b = applicationContext.getBean(<span class="string">"bookDaoImpl"</span>,BookDaoImpl.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用组件注解的 value 属性指定 bean 的 id</span></span><br><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"bookDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">BookDaoImpl b = applicationContext.getBean(<span class="string">"bookDao"</span>,BookDaoImpl.class);</span><br></pre></td></tr></table></figure>

<p>注意：事实上 Spring 并没有能力识别一个组件到底是不d是它所标记的类型，即使将 @Respository 注解用在一个表述层控制器组件上面也不会产生任何错误，所以 @Respository、@Service、@Controller 这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。</p>
<h5 id="6-组件的作用域"><a href="#6-组件的作用域" class="headerlink" title="6.组件的作用域"></a>6.组件的作用域</h5><p>​    默认是单例的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>)  <span class="comment">//多实例</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-3-扫描组件"><a href="#2-5-3-扫描组件" class="headerlink" title="2.5.3 扫描组件"></a>2.5.3 扫描组件</h4><p>前提：引入context命名空间,导入aop jar包。</p>
<p>组件被上述注解标识后还需要通过 Spring 进行扫描才能够侦测到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yyy"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详细说明: </p>
<p>①base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包及其子包中的所有类。</p>
<p>②当需要扫描多个包时可以使用逗号分隔。 </p>
<p>③如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类，示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.atguigu.component"</span> <span class="attr">resource-pattern</span>=<span class="string">"autowire/*.class"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>④包含与排除 </p>
<p>&lt;context:include-filter&gt;子节点表示要包含的目标类 </p>
<p>注意：通常需要与 use-default-filters 属性配合使用才能够达到“仅包含某些组件”这样的效果。即：通过将 use-default-filters 属性设置为 false,禁用默认过滤器，然后扫描的就只是 include-filter 中的规则指定的组件了。 </p>
<p>&lt;context:exclude-filter&gt;子节点表示要排除在外的目标类 。</p>
<p>&lt;component-scan&gt; 下可以拥有若干个 include-filter 和 exclude-filter 子节点。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575120562513.png" alt="1575120562513"></p>
<h4 id="2-5-4-组件装配"><a href="#2-5-4-组件装配" class="headerlink" title="2.5.4 组件装配"></a>2.5.4 组件装配</h4><h5 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h5><p>​    Controller 组件中往往需要用到 Service 组件的实例,Service 组件中往往需要用到 Repository 组件的实例。Spring 可以通过注解的方式帮我们实现属性的装配。</p>
<h5 id="2-实现依据"><a href="#2-实现依据" class="headerlink" title="2.实现依据"></a>2.实现依据</h5><p>​    在指定要扫描的包时,&lt;context:component-scan&gt; 元素会自动注册一个 bean 的后置处理器：AutowiredAnnotationBeanPostProcessor 的实例。该后置处理器可以自动装配标记了<strong>@Autowired</strong>、@Resource 或@Inject 注解的属性。 </p>
<h5 id="3-Autowired-注解"><a href="#3-Autowired-注解" class="headerlink" title="3.@Autowired 注解"></a>3.@Autowired 注解</h5><p>①根据类型实现自动装配。 </p>
<p>②构造器、普通字段(即使是非 public)、一切具有参数的方法都可以应用@Autowired 注解 。</p>
<p>③默认情况下，所有使用@Autowired 注解的属性都需要被设置。当 Spring 找不到匹配的 bean 装配属性时，会抛出异常。 </p>
<p>④若某一属性允许不被设置，可以设置@Autowired 注解的 required 属性为 false,找不到装配Null。 </p>
<p>⑤<strong>默认情况下，当 IOC 容器里存在多个类型兼容的 bean 时，Spring 会尝试匹配 bean的 id 值是否与变量名相同，如果相同则进行装配。如果 bean 的 id 值不相同,通过类型的自动装配将无法工作。此时可以在@Qualifier 解里提供 bean 的名称。Spring 甚至允许在方法的形参上标注@Qualifiter 注解以指定注入 bean 的名称。</strong> </p>
<p>⑥@Autowired 注解也可以应用在数组类型的属性上，此时 Spring 将会把所有匹配的bean 进行自动装配。 </p>
<p>⑦@Autowired 注解也可以应用在集合属性上，此时 Spring 读取该集合的类型信息，然后自动装配所有与之兼容的 bean。 </p>
<p>⑧@Autowired 注解用在 java.util.Map 上时，若该 Map 的键值为 String，那么 Spring 将自动装配与值类型兼容的 bean 作为值，并以 bean 的 id 值作为键。 </p>
<p>⑨Spring自己的注解，最强大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServlet</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> BookServiceImpl bookServiceImpl;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"BookServlet 调用业务层"</span>);</span><br><span class="line">		bookServiceImpl.query();</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span></span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> BookDaoImpl bookDaoImpl;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"BookService 调用持久层"</span>);</span><br><span class="line">		bookDaoImpl.sel();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"BookDao"</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BookServlet bookServlet = applicationContext.getBean(<span class="string">"bookServlet"</span>,BookServlet.class);</span><br><span class="line">bookServlet.show();</span><br></pre></td></tr></table></figure>





<h5 id="4-Resource注解"><a href="#4-Resource注解" class="headerlink" title="4.@Resource注解"></a>4.@Resource注解</h5><p>@Resource 注解要求提供一个 bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 bean 的名称。(javaee:java的标准,扩展性更强) </p>
<h5 id="5-Inject-注解"><a href="#5-Inject-注解" class="headerlink" title="5.@Inject 注解"></a>5.@Inject 注解</h5><p>@Inject 和@Autowired 注解一样也是按类型注入匹配的 bean，但没有 reqired 属性。</p>
<p><strong>建议使用 @Autowired 注解。</strong></p>
<h3 id="2-6-可以使用的值"><a href="#2-6-可以使用的值" class="headerlink" title="2.6 可以使用的值"></a>2.6 可以使用的值</h3><h4 id="2-6-1-字面值"><a href="#2-6-1-字面值" class="headerlink" title="2.6.1 字面值"></a>2.6.1 字面值</h4><ol>
<li>可用字符串表示的值，可以通过 &lt;value&gt; 元素标签或 value 属性进行注入。</li>
<li>基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式</li>
<li>若字面值中包含特殊字符，可以使用&lt;![CDATA[]]&gt; 把字面值包裹起来。</li>
</ol>
<h4 id="2-6-2-null"><a href="#2-6-2-null" class="headerlink" title="2.6.2 null"></a>2.6.2 null</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-6-3-引用外部已声明的bean"><a href="#2-6-3-引用外部已声明的bean" class="headerlink" title="2.6.3 引用外部已声明的bean"></a>2.6.3 引用外部已声明的bean</h4><p>​    组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能。要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用。在 Bean 的配置文件中, 可以通过 &lt;ref&gt; 元素或 ref  属性为 Bean 的属性或构造器参数指定对 Bean 的引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Emp"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">ref</span>=<span class="string">"dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptno"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dname"</span>  <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-6-4-给bean的级联属性赋值"><a href="#2-6-4-给bean的级联属性赋值" class="headerlink" title="2.6.4 给bean的级联属性赋值"></a>2.6.4 给bean的级联属性赋值</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Emp"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"empno"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ename"</span> <span class="attr">value</span>=<span class="string">"yyy"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sal"</span> <span class="attr">value</span>=<span class="string">"2000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">ref</span>=<span class="string">"dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept.deptno"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-6-5-内部bean"><a href="#2-6-5-内部bean" class="headerlink" title="2.6.5 内部bean"></a>2.6.5 内部bean</h4><p>​    在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean。</p>
<p>​    当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 内部 Bean 声明直接包含在 &lt;property&gt; 或&lt;constructor-arg&gt; 元素里, 不需要设置任何 id 或 name 属性。<strong>内部 Bean 不能使用在任何其他地方。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.yyy.entity.Emp&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;empno&quot; value=&quot;1&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;ename&quot; value=&quot;yyy&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;sal&quot; value=&quot;2000&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;dept&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;com.yyy.entity.Dept&quot;&gt;</span><br><span class="line">        	&lt;property name=&quot;deptno&quot; value=&quot;10&quot;&gt;&lt;/property&gt;</span><br><span class="line">			&lt;property name=&quot;dname&quot;  value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-7-集合属性"><a href="#2-7-集合属性" class="headerlink" title="2.7 集合属性"></a>2.7 集合属性</h3><h4 id="2-7-1-数组与List"><a href="#2-7-1-数组与List" class="headerlink" title="2.7.1 数组与List"></a>2.7.1 数组与List</h4><p>​    配置 java.util.List 类型的属性, 需要指定 &lt;list&gt;  标签, 在标签里包含一些元素. 这些标签可以通过 &lt;value&gt; 指定简单的常量值, 通过&lt;ref&gt; 指定对其他 Bean 的引用,通过&lt;bean&gt; 指定内置 Bean 定义,通过 &lt;null/&gt; 指定空元素, 甚至可以内嵌其他集合。数组的定义和 List 一样, 都使用 &lt;list&gt;,数组也可以使用&lt;array&gt;。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>唱<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>跳<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>rap<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-2-Set"><a href="#2-7-2-Set" class="headerlink" title="2.7.2 Set"></a>2.7.2 Set</h4><p>​    配置 java.util.Set 需要使用&lt;set&gt;标签，定义的方法与 List 一样。 </p>
<h4 id="2-7-3-Map"><a href="#2-7-3-Map" class="headerlink" title="2.7.3 Map"></a>2.7.3 Map</h4><p>​    Java.util.Map 通过&lt;map&gt; 标签定义, &lt;map&gt; 标签里可以使用多个 &lt;entry&gt; 作为子标签。每个条目包含一个键和一个值. 必须在 &lt;key&gt; 标签里定义键因为键和值的类型没有限制, 所以可以自由地为它们指定 &lt;value&gt;, &lt;ref&gt;, &lt;bean&gt; 或 &lt;null&gt; 元素. 可以将 Map 的键和值作为 &lt;entry&gt; 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"yyy"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--另一种写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yyy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-4-Properties"><a href="#2-7-4-Properties" class="headerlink" title="2.7.4 Properties"></a>2.7.4 Properties</h4><p>​    使用 &lt;props&gt; 定义 java.util.Properties, 该标签使用多个 &lt;prop&gt; 作为子标签. 每个 &lt;prop&gt; 标签必须定义 key 属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"driver"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"url"</span>&gt;</span>jdbc:mysql://localhost:3306/SSM<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-5-使用util命名空间"><a href="#2-7-5-使用util命名空间" class="headerlink" title="2.7.5 使用util命名空间"></a>2.7.5 使用util命名空间</h4><p>​    使用基本的集合标签定义集合时, 不能将集合作为独立的 Bean 定义, 导致其他 Bean 无法引用该集合, 所以无法在不同 Bean 之间共享集合。可以使用 util 命名空间里的集合标签定义独立的集合 Bean。需要注意的是, 必须在 &lt;beans&gt; 根元素里添加 util 命名空间定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>唱<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>跳<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>rap<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"唱"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"跳"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"篮球"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"driver"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"url"</span>&gt;</span>jdbc:mysql://localhost:3306/SSM<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-8-Bean的高级配置"><a href="#2-8-Bean的高级配置" class="headerlink" title="2.8 Bean的高级配置"></a>2.8 Bean的高级配置</h3><h4 id="2-8-1-继承Bean的配置"><a href="#2-8-1-继承Bean的配置" class="headerlink" title="2.8.1 继承Bean的配置"></a>2.8.1 继承Bean的配置</h4><p>​    Spring 允许继承 bean 的配置, 被继承的 bean 称为父 bean,继承这个父 Bean 的 Bean 称为子 Bean。子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置;子 Bean 也可以覆盖从父 Bean 继承过来的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"yinyuanyang"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span> <span class="attr">parent</span>=<span class="string">"user1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    父 Bean 可以作为配置模板, 也可以作为 Bean 实例. 若只想把父 Bean 作为模板, 可以设置 &lt;bean&gt; 的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean。</p>
<h4 id="2-8-2-依赖Bean的配置"><a href="#2-8-2-依赖Bean的配置" class="headerlink" title="2.8.2 依赖Bean的配置"></a>2.8.2 依赖Bean的配置</h4><p>​    有的时候创建一个 bean 的时候需要保证另外一个 bean 也被创建，这时我们称前面的 bean 对后面的 bean 有依赖。例如：要求创建 Employee 对象的时候必须创建 Department。这里需要注意的是依赖关系不等于引用关系，Employee 即使依赖 Department 也可以不引用它。 </p>
<p>​    Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，<strong>前置依赖的 Bean 会在本 Bean 实例化之前创建好</strong>。如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp03"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.parent.bean.Employee"</span> <span class="attr">depends-on</span>=<span class="string">"dept"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"empId"</span> <span class="attr">value</span>=<span class="string">"1003"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"empName"</span> <span class="attr">value</span>=<span class="string">"Kate"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-9-Bean的作用域"><a href="#2-9-Bean的作用域" class="headerlink" title="2.9 Bean的作用域"></a>2.9 Bean的作用域</h3><p>​     在 Spring 中，可以在&lt;bean&gt;元素的 scope 属性里设置 bean 的作用域，以决定这个 bean是单实例的还是多实例的。 </p>
<p>​    默认情况下，Spring 只为每个在 IOC 容器里声明的 bean 创建唯一一个实例，整个 IOC 容器范围内都能共享该实例：所有后续的 getBean()调用和 bean 引用都将返回这个唯一的 bean 实例。该作用域被称为 singleton，它是所有 bean 的默认作用域。</p>
<h4 id="2-9-1-singleton"><a href="#2-9-1-singleton" class="headerlink" title="2.9.1 singleton"></a>2.9.1 singleton</h4><p>​    在SpringIOC容器中仅存在一个Bean实例,Bean以单实例的方式存在,默认。</p>
<h4 id="2-9-2-prototype"><a href="#2-9-2-prototype" class="headerlink" title="2.9.2 prototype"></a>2.9.2 prototype</h4><p>​    每次调用getBean()时都会返回一个新实例。</p>
<h4 id="2-9-3-request"><a href="#2-9-3-request" class="headerlink" title="2.9.3 request"></a>2.9.3 request</h4><p>​    每次HTTP请求都会创建一个新的Bean。（没用）</p>
<h4 id="2-9-4-session"><a href="#2-9-4-session" class="headerlink" title="2.9.4 session"></a>2.9.4 session</h4><p>​    同一个HTTP Session共享一个Bean。（没用）</p>
<h4 id="2-9-5-总结"><a href="#2-9-5-总结" class="headerlink" title="2.9.5 总结"></a>2.9.5 总结</h4><p>当 bean 的作用域为单例时，Spring 会在 IOC 容器对象创建时就创建 bean 的对象实例。 </p>
<p>当 bean 的作用域为 prototype 时，IOC 容器在获取 bean 的实例时创建 bean 的实例对象。</p>
<h3 id="2-10-Bean的生命周期"><a href="#2-10-Bean的生命周期" class="headerlink" title="2.10 Bean的生命周期"></a>2.10 Bean的生命周期</h3><h4 id="2-10-1-IOC容器中的生命周期方法"><a href="#2-10-1-IOC容器中的生命周期方法" class="headerlink" title="2.10.1 IOC容器中的生命周期方法"></a>2.10.1 IOC容器中的生命周期方法</h4><p>1) Spring IOC 容器可以管理 bean 的生命周期，Spring 允许在 bean 生命周期内特定的时间点执行指定的任务。 </p>
<p>2) Spring IOC 容器对 bean 的生命周期进行管理的过程： </p>
<p>​    ① 通过构造器或工厂方法创建 bean 实例 </p>
<p>​    ② 为 bean 的属性设置值和对其他 bean 的引用 </p>
<p>​    ③ 调用 bean 的初始化方法 </p>
<p>​    ④ bean 可以使用了 </p>
<p>​    ⑤ 当容器关闭时，调用 bean 的销毁方法 </p>
<p>3) 在配置 bean 时，通过 init-method 和 destroy-method 属性为 bean 指定初始化和销毁方法。</p>
<h4 id="2-10-2-创建Bean后置处理器"><a href="#2-10-2-创建Bean后置处理器" class="headerlink" title="2.10.2 创建Bean后置处理器"></a>2.10.2 创建Bean后置处理器</h4><p>​    Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。</p>
<p>​    Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性。<br>​    对Bean 后置处理器而言, 需要实现 org.springframework.beans.factory.config.BeanPostProcessor 接口。在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将后置处理器注册在Spring容器中</span></span><br><span class="line">&lt;bean id=<span class="string">"myBeanPostPeocessor"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yyy.test.MyBeanPostProcessor"</span>&gt; 	</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<h4 id="2-10-3-添加Bean后置处理器后-Bean-的生命周期"><a href="#2-10-3-添加Bean后置处理器后-Bean-的生命周期" class="headerlink" title="2.10.3 添加Bean后置处理器后 Bean 的生命周期"></a>2.10.3 添加Bean后置处理器后 Bean 的生命周期</h4><p>Spring IOC 容器对 Bean 的生命周期进行管理的过程:<br>    1.通过构造器或工厂方法创建 Bean 实例<br>    2.为 Bean 的属性设置值和对其他 Bean 的引用<br>    3.将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法<br>    4.调用 Bean 的初始化方法<br>    5.将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法<br>    6.Bean 可以使用了<br>    7.当容器关闭时, 调用 Bean 的销毁方法</p>
<h3 id="2-11-引用外部属性文件"><a href="#2-11-引用外部属性文件" class="headerlink" title="2.11 引用外部属性文件"></a>2.11 引用外部属性文件</h3><p>​    当 bean 的配置信息逐渐增多时，查找和修改一些 bean 的配置信息就变得愈加困难。这 时可以将一部分信息提取到 bean 配置文件的外部，以 properties 格式的属性文件保存起来，同时在 bean 的配置文件中引用 properties 属性文件中的内容，从而实现一部分属性值在发生变化时仅修改 properties 属性文件即可。这种技术多用于连接数据库的基本信息的配置。</p>
<h4 id="2-11-1-直接配置"><a href="#2-11-1-直接配置" class="headerlink" title="2.11.1 直接配置"></a>2.11.1 直接配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/SSM"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span> 		 	 </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-11-2-使用外部属性文件"><a href="#2-11-2-使用外部属性文件" class="headerlink" title="2.11.2 使用外部属性文件"></a>2.11.2 使用外部属性文件</h4><h5 id="1-创建properties属性文件"><a href="#1-创建properties属性文件" class="headerlink" title="1.创建properties属性文件"></a>1.创建properties属性文件</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/SSM</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<h5 id="2-引入context命名空间"><a href="#2-引入context命名空间" class="headerlink" title="2.引入context命名空间"></a>2.引入context命名空间</h5><h5 id="3-指定properties属性文件的位置"><a href="#3-指定properties属性文件的位置" class="headerlink" title="3.指定properties属性文件的位置"></a>3.指定properties属性文件的位置</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-从properties属性文件中引入属性值"><a href="#4-从properties属性文件中引入属性值" class="headerlink" title="4.从properties属性文件中引入属性值"></a>4.从properties属性文件中引入属性值</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span> 		 	 </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2-12-SpEL"><a href="#2-12-SpEL" class="headerlink" title="2.12 SpEL"></a>2.12 SpEL</h3><p>​    Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。</p>
<p>​    语法类似于 EL：<strong>SpEL 使用</strong> <strong>#{ } 作为定界符</strong>，所有在大框号中的字符都将被认为是 SpEL。SpEL 为 bean 的属性进行动态赋值提供了便利。通过 SpEL 可以实现：<br>​    1.通过 bean 的 id 对 bean 进行引用<br>​    2.调用方法以及引用对象中的属性<br>​    3.计算表达式的值<br>​    4.正则表达式的匹配</p>
<h4 id="2-12-1-字面量"><a href="#2-12-1-字面量" class="headerlink" title="2.12.1 字面量"></a>2.12.1 字面量</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">整数：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span> <span class="attr">value</span>=<span class="string">"#&#123;5&#125;"</span>/&gt;</span></span><br><span class="line">小数：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"frequency"</span> <span class="attr">value</span>=<span class="string">"#&#123;89.7&#125;"</span>/&gt;</span></span><br><span class="line">科学计数法：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"capacity"</span> <span class="attr">value</span>=<span class="string">"#&#123;1e4&#125;"</span>/&gt;</span></span><br><span class="line">String可以使用单引号或者双引号作为字符串的定界符号：</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;'Chuck'&#125;"</span>/&gt;</span> </span><br><span class="line">或 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">'name'</span> <span class="attr">value</span>=<span class="string">'#&#123;"Chuck"&#125;'</span>/&gt;</span></span><br><span class="line">Boolean：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enabled"</span> <span class="attr">value</span>=<span class="string">"#&#123;false&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-12-2-引用其他的Bean、属性和方法"><a href="#2-12-2-引用其他的Bean、属性和方法" class="headerlink" title="2.12.2 引用其他的Bean、属性和方法"></a>2.12.2 引用其他的Bean、属性和方法</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">引用其他的Bean</span><br><span class="line"><span class="comment">&lt;!--之前的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">ref</span>=<span class="string">"dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 使用SpEL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">value</span>=<span class="string">"#&#123;dept&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引用其他对象的非静态属性</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptName"</span> <span class="attr">value</span>=<span class="string">"#&#123;dept.deptName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">调用非静态方法</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">value</span>=<span class="string">"#&#123;dept.toString()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">调用静态方法或静态属性(#&#123;T(类名).方法(属性)&#125;)</span><br><span class="line">通过 T() 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应的方法或属性。</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"circle"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).PI*20&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-12-3-运算符"><a href="#2-12-3-运算符" class="headerlink" title="2.12.3 运算符"></a>2.12.3 运算符</h4><p>1) 算术运算符：+、-、*、/、%、^ </p>
<p>2) 字符串连接：+ </p>
<p>3) 比较运算符：&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge </p>
<p>4) 逻辑运算符：and, or, not, |</p>
<p>5) 三目运算符：判断条件?判断结果为 true 时的取值:判断结果为 false 时的取值 </p>
<p>6) 正则表达式：matches</p>
<h2 id="第三章-AOP"><a href="#第三章-AOP" class="headerlink" title="第三章 AOP"></a>第三章 AOP</h2><h3 id="3-1-动态代理"><a href="#3-1-动态代理" class="headerlink" title="3.1 动态代理"></a>3.1 动态代理</h3><h4 id="3-1-1代理设计模式的原理"><a href="#3-1-1代理设计模式的原理" class="headerlink" title="3.1.1代理设计模式的原理"></a>3.1.1代理设计模式的原理</h4><p>​    使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<h4 id="3-1-2-动态代理的方式"><a href="#3-1-2-动态代理的方式" class="headerlink" title="3.1.2 动态代理的方式"></a><strong>3.1.2</strong> <strong>动态代理的方式</strong></h4><p>1) 基于接口实现动态代理： JDK 动态代理 </p>
<p>2) 基于继承实现动态代理： Cglib、Javassist 动态代理</p>
<h3 id="3-2-AOP"><a href="#3-2-AOP" class="headerlink" title="3.2 AOP"></a>3.2 AOP</h3><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p>1) AOP(Aspect-Oriented Programming，<strong>面向切面编程</strong>)：是一种新的方法论，是对传统 OOP(Object-Oriented Programming，面向对象编程)的补充。 </p>
<p>2) AOP 编程操作的主要对象是切面(aspect)，而切面<strong>模块化横切关注点</strong>。 </p>
<p>3) 在应用 AOP 编程时，仍然需要定义公共功能，但可以明确的定义这个功能应用在哪里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的类里——这样的类我们通常称之为“切面”。 </p>
<p>4) AOP 的好处： </p>
<p>① 每个事物逻辑位于一个位置，代码不分散，便于维护和升级。 </p>
<p>② 业务模块更简洁，只包含核心业务代码 </p>
<p>③ AOP 图解：</p>
<p><img src="file:///C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTencent%5CUsers%5C763984979%5CQQ%5CWinTemp%5CRichOle%5CKWY~RG2%7BR5G5%7D~%60@W5KB4%5D8.png" alt="img"></p>
<h4 id="3-2-2-术语"><a href="#3-2-2-术语" class="headerlink" title="3.2.2 术语"></a>3.2.2 术语</h4><h5 id="1-横切关注点"><a href="#1-横切关注点" class="headerlink" title="1.横切关注点"></a><strong>1.横切关注点</strong></h5><p>从每个方法中抽取出来的同一类非核心业务。 </p>
<h5 id="2-切面-Aspect"><a href="#2-切面-Aspect" class="headerlink" title="2.切面(Aspect)"></a><strong>2.切面(Aspect)</strong></h5><p>封装横切关注点信息的类，每个关注点体现为一个通知方法。 </p>
<p><strong>3.通知(Advice)</strong> </p>
<p>切面必须要完成的各个具体工作。 </p>
<h5 id="4-目标-Target"><a href="#4-目标-Target" class="headerlink" title="4.目标(Target)"></a>4.目标(Target)</h5><p>被通知的对象 </p>
<h5 id="5-代理-Proxy"><a href="#5-代理-Proxy" class="headerlink" title="5.代理(Proxy)"></a><strong>5.代理(Proxy)</strong></h5><p>向目标对象应用通知之后创建的代理对象。 </p>
<h5 id="6-连接点-Joinpoint"><a href="#6-连接点-Joinpoint" class="headerlink" title="6.连接点(Joinpoint)"></a><strong>6.连接点(Joinpoint)</strong></h5><p>横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。例如：类某个方法调用前、调用后、方法捕获到异常后等。</p>
<p>在应用程序中可以使用横纵两个坐标来定位一个具体的连接点。</p>
<h5 id="7-切入点-pointcut"><a href="#7-切入点-pointcut" class="headerlink" title="*7. 切入点(pointcut) *"></a>*<em>7. 切入点(pointcut) *</em></h5><p>定位连接点的方式。每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物。如果把连接点看作数据库中的记录，那么切入点就是查询条件——AOP 可以通过切入点定位到特定的连接点。切点通过 org.springframework.aop.Pointcut 接口进行描述,它使用类和方法作为连接点的查询条件。</p>
<h3 id="3-3-AspectJ"><a href="#3-3-AspectJ" class="headerlink" title="3.3 AspectJ"></a>3.3 AspectJ</h3><h4 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3.3.1 简介"></a>3.3.1 简介</h4><p>AspectJ：Java 社区里最完整最流行的 AOP 框架。 </p>
<p>在 Spring2.0 以上版本中，可以使用基于 AspectJ 注解或基于 XML 配置的 AOP。 </p>
<h4 id="3-3-2-在-Spring-中启用-AspectJ-注解支持"><a href="#3-3-2-在-Spring-中启用-AspectJ-注解支持" class="headerlink" title="3.3.2  在 Spring 中启用 AspectJ 注解支持"></a>3.3.2  <strong>在</strong> <strong>Spring</strong> <strong>中启用</strong> <strong>AspectJ</strong> <strong>注解支持</strong></h4><h5 id="1-导入-JAR-包"><a href="#1-导入-JAR-包" class="headerlink" title="1.导入 JAR 包"></a>1.导入 JAR 包</h5><p>com.springsource.net.sf.cglib-2.2.0.jar </p>
<p>com.springsource.org.aopalliance-1.0.0.jar </p>
<p>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar </p>
<p>spring-aop-4.0.0.RELEASE.jar </p>
<p>spring-aspects-4.0.0.RELEASE.jar </p>
<h5 id="2-引入-aop-名称空间"><a href="#2-引入-aop-名称空间" class="headerlink" title="2. 引入 aop 名称空间"></a>2. 引入 aop 名称空间</h5><h5 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h5><p>​    当 Spring IOC 容器侦测到 bean 配置文件中的&lt;aop:aspectj-autoproxy&gt;元素时，会自动为与 AspectJ 切面匹配的 bean 创建代理。</p>
<h4 id="3-3-3-用-AspectJ-注解声明切面"><a href="#3-3-3-用-AspectJ-注解声明切面" class="headerlink" title="3.3.3 用 AspectJ 注解声明切面"></a><strong>3.3.3 用 AspectJ 注解声明切面</strong></h4><p>1) 要在 Spring 中声明 AspectJ 切面，只需要在 IOC 容器中将切面声明为 bean 实例。 </p>
<p>2) 当在 Spring IOC 容器中初始化 AspectJ 切面之后，Spring IOC 容器就会为那些与 AspectJ切面相匹配的 bean 创建代理。 </p>
<p>3) 在 AspectJ 注解中，切面只是一个带有@Aspect 注解的 Java 类，它往往要包含很多通知。 </p>
<p>4) 通知是标注有某种注解的简单的 Java 方法。 </p>
<p>5) AspectJ 支持 5 种类型的通知注解： </p>
<p>① @Before：前置通知，在方法执行之前执行 </p>
<p>② @After：后置通知，在方法执行之后执行 </p>
<p>③ @AfterRunning：返回通知，在方法返回结果之后执行 </p>
<p>④ @AfterThrowing：异常通知，在方法抛出异常之后执行 </p>
<p>⑥ @Around：环绕通知，围绕着方法执行</p>
<h3 id="3-4-切入点表达式"><a href="#3-4-切入点表达式" class="headerlink" title="3.4 切入点表达式"></a>3.4 切入点表达式</h3><h4 id="3-4-1-作用"><a href="#3-4-1-作用" class="headerlink" title="3.4.1 作用"></a>3.4.1 作用</h4><p>通过表达式的方式定位一个或多个具体的连接点。 </p>
<h4 id="3-4-2-语法细节"><a href="#3-4-2-语法细节" class="headerlink" title="3.4.2 语法细节"></a><strong>3.4.2 语法细节</strong></h4><p>execution([权限修饰符] [返回值类型] [简单类名/全类名] [方法名]([参数列表]))</p>
<p>例子：</p>
<p>execution(<strong><strong>* com.atguigu.spring.ArithmeticCalculator.*</strong></strong>(<strong>..</strong>)) </p>
<p>含义 ArithmeticCalculator 接口中声明的所有方法。 </p>
<p>第一个“*”代表任意修饰符及任意返回值。 </p>
<p>第二个“*”代表任意方法。 </p>
<p>“..”匹配任意数量、任意类型的参数。 </p>
<p>若目标类、接口与该切面类在同一个包中可以省略包名</p>
<p>在 AspectJ 中，切入点表达式可以通过 “&amp;&amp;”、“||”、“!”等操作符结合起来。</p>
<h3 id="3-5-当前连接点细节"><a href="#3-5-当前连接点细节" class="headerlink" title="3.5 当前连接点细节"></a><strong>3.5 当前连接点细节</strong></h3><h4 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1 概述"></a>3.5.1 概述</h4><p>​    切入点表达式通常都会是从宏观上定位一组方法，和具体某个通知的注解结合起来就能够确定对应的连接点。那么就一个具体的连接点而言，我们可能会关心这个连接点的一些具体信息，例如：当前连接点所在方法的方法名、当前传入的参数值等等。这些信息都封装在 JoinPoint 接口的实例对象中。 </p>
<h4 id="3-5-2-JoinPoint"><a href="#3-5-2-JoinPoint" class="headerlink" title="3.5.2  JoinPoint"></a>3.5.2  JoinPoint</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String methodName=joinPoint.getSignature().getName(); <span class="comment">//方法名</span></span><br><span class="line">List&lt;Object&gt; args=Arrays.asList(joinPoint.getArgs()); <span class="comment">//参数列表</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6-通知"><a href="#3-6-通知" class="headerlink" title="3.6 通知"></a>3.6 通知</h3><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a><strong>3.6.1 概述</strong></h4><p>1) 在具体的连接点上要执行的操作。 </p>
<p>2) 一个切面可以包括一个或者多个通知。 </p>
<p>3) 通知所使用的注解的值往往是切入点表达式。 </p>
<p>1) 前置通知：在方法执行之前执行的通知 </p>
<p>2) 使用@Before 注解 </p>
<h4 id="3-6-2-后置通知"><a href="#3-6-2-后置通知" class="headerlink" title="3.6.2 后置通知"></a><strong>3.6.2</strong> <strong>后置通知</strong></h4><p>1) 后置通知：后置通知是在连接点完成之后执行的，即连接点返回结果或者抛出异常的时 </p>
<p>候 </p>
<p>2) 使用@After 注解 </p>
<h4 id="3-6-3-返回通知"><a href="#3-6-3-返回通知" class="headerlink" title="3.6.3 返回通知"></a><strong>3.6.3</strong> <strong>返回通知</strong></h4><p>1) 返回通知：无论连接点是正常返回还是抛出异常，后置通知都会执行。如果只想在连接 </p>
<p>点返回的时候记录日志，应使用返回通知代替后置通知。 </p>
<p>2) 使用@AfterReturning 注解,在返回通知中访问连接点的返回值 </p>
<p>①在返回通知中，只要将 returning 属性添加到@AfterReturning 注解中，就可以访问连 </p>
<p>接点的返回值。该属性的值即为用来传入返回值的参数名称 </p>
<p>②必须在通知方法的签名中添加一个同名参数。在运行时 Spring AOP 会通过这个参数 </p>
<p>传递返回值 </p>
<p>③原始的切点表达式需要出现在 pointcut 属性中 </p>
<h4 id="5-3-5-异常通知"><a href="#5-3-5-异常通知" class="headerlink" title="5.3.5 异常通知"></a><strong>5.3.5</strong> <strong>异常通知</strong></h4><p>1) 异常通知：只在连接点抛出异常时才执行异常通知 </p>
<p>2) 将 throwing 属性添加到@AfterThrowing 注解中，也可以访问连接点抛出的异常。 </p>
<p>Throwable 是所有错误和异常类的顶级父类，所以在异常通知方法可以捕获到任何错误 </p>
<p>和异常。 </p>
<p>3) 如果只对某种特殊的异常类型感兴趣，可以将参数声明为其他异常的参数类型。然后通 </p>
<p>知就只在抛出这个类型及其子类的异常时才被执行 </p>
<p>38</p>
<p>更多 Java –大数据 –前端 –python 人工智能资料下载，可访问百度：尚硅谷官网<strong>JAVAEE 课程系列</strong> </p>
<p><strong>—————————————————————————————</strong> </p>
<h4 id="5-3-6-环绕通知"><a href="#5-3-6-环绕通知" class="headerlink" title="5.3.6 环绕通知"></a><strong>5.3.6</strong> <strong>环绕通知</strong></h4><p>1) 环绕通知是所有通知类型中功能最为强大的，能够全面地控制连接点，甚至可以控制是 </p>
<p>否执行连接点。 </p>
<p>2) 对于环绕通知来说，连接点的参数类型必须是 ProceedingJoinPoint。它是 JoinPoint 的 </p>
<p>子接口，允许控制何时执行，是否执行连接点。 </p>
<p>3) 在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed()方法来执行被代理的方法。 </p>
<p>如果忘记这样做就会导致通知被执行了，但目标方法没有被执行。 </p>
<p>4) 注意：环绕通知的方法需要返回目标方法执行之后的结果，即调用 joinPoint.proceed(); </p>
<p>的返回值，否则会出现空指针异常。 </p>
]]></content>
  </entry>
  <entry>
    <title>Mysql数据库（基础）</title>
    <url>/2019/10/25/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
    <content><![CDATA[<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p>1、DB：数据库，保存一组有组织的数据的容器。<br>​2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据，常见的DBMS为MySql,Oracle,SqlServer,DB2。。。<br>​3、SQL:结构化查询语言，用于和DBMS通信的语言。</p>
<h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>​    方式一：计算机——右击管理——服务<br>​    方式二：通过管理员身份运行<br>​    net start 服务名（启动服务）<br>​    net stop 服务名（停止服务）</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：通过mysql自带的客户端</span><br><span class="line">只限于root用户</span><br><span class="line"></span><br><span class="line">方式二：通过windows自带的客户端</span><br><span class="line">登录：</span><br><span class="line">mysql 【-h主机名 -P端口号 】-u用户名 -p密码</span><br><span class="line">例如： mysql -u root -p123456</span><br><span class="line">退出：</span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure>



<h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名;</span><br><span class="line"></span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line"></span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line">	列名 列类型，</span><br><span class="line">	...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure>





<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写。<br>​    2.每条命令最好用分号结尾。<br>​    3.每条命令根据需要，可以进行缩进或换行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字    -- 注释文字 (注意中间要带有一个空格才能生效)</span><br><span class="line">多行注释：/* 注释文字 */</span><br></pre></td></tr></table></figure>



<h2 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h2><p><strong>1.DQL（Data Query Language)：数据查询语言</strong><br>        select<br><strong>2.DML  (Data Manipulate Language):   数据操作语言</strong><br>        insert 、update、delete<br><strong>3.DDL（Data Define Languge)：数据定义语言</strong><br>        create、drop、alter<br><strong>4.TCL （Transaction Control Language)：事务控制语言</strong><br>        commit、rollback、savepoint</p>
<p><strong>5.DCL（Data Control Language)：数据控制语言</strong></p>
<p>   　 grant、revoke</p>
<hr>
<h3 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h3><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">查询表的所有数据:  SELECT * FROM 表名;  </span><br><span class="line">查询表中指定字段的值: SELECT 字段1,字段2...字段n FROM 表名;</span><br></pre></td></tr></table></figure>

<p>特点：<br>①通过select查询完的结果 ,是一个虚拟的表格，不是真实存在。<br>②要查询的东西可以是常量值、可以是表达式、可以是字段、可以是函数。</p>
<p>4</p>
<h5 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#给查询结果中的字段使用别名</span><br><span class="line">字段名 as 别名</span><br><span class="line">或者</span><br><span class="line">字段名 &quot;别名&quot;</span><br><span class="line">SELECT name as &quot;花名&quot; FROM  flower;</span><br></pre></td></tr></table></figure>

<p>注意: as可以省略不写，别名中没有特殊字符，双引号也可以省略不写。</p>
<h5 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 字段1,字段2...字段n  FROM 表名;</span><br></pre></td></tr></table></figure>

<p>注意：去除重复的规则是按照行进行去除的,多行数据完全相同取其一,DISTINCT必须放在要查询字段的开头。</p>
<h5 id="号"><a href="#号" class="headerlink" title="+号"></a>+号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#仅仅只有一个功能:运算符</span><br><span class="line"></span><br><span class="line">#两个操作数为数值型，则做加法运算</span><br><span class="line">SELECT 100+90;  -- 190</span><br><span class="line"></span><br><span class="line">#只要其中一方为字符型，试图将字符型数值转换成数值型 </span><br><span class="line">#1.如果转换成功,则继续做加法运算</span><br><span class="line">#2.如果转换失败,则将字符型数值转换为0</span><br><span class="line">SELECT &quot;100&quot;+90; -- 190</span><br><span class="line">SELECT &quot;Tom&quot;+90; -- 90</span><br><span class="line"></span><br><span class="line">#只要其中一方为null,则结果肯定为null</span><br><span class="line">SELECT null+90; -- null</span><br></pre></td></tr></table></figure>



<h5 id="concat实现拼接操作"><a href="#concat实现拼接操作" class="headerlink" title="concat实现拼接操作"></a>concat实现拼接操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用方法 </span><br><span class="line">CONCAT(str1,str2...)  </span><br><span class="line"></span><br><span class="line">SELECT CONCAT(1,3,4);  测试  -- 一个数字参数被转化为与之相等的二进制字符串格式</span><br><span class="line">SELECT CONCAT(id,&apos;,&apos;,name) &quot;编号,花名&quot; from flower;</span><br></pre></td></tr></table></figure>

<p>注意:返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。</p>
<hr>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>条件查询：根据条件过滤原始表的数据，查询到想要的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 要查询的字段|表达式|常量值|函数 from 表名 where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="一、条件表达式"><a href="#一、条件表达式" class="headerlink" title="一、条件表达式"></a>一、条件表达式</h5><p>条件运算符：&gt;   &lt;   &gt;=   &lt;=   =   &lt;&gt;   !=</p>
<h5 id="二、逻辑表达式"><a href="#二、逻辑表达式" class="headerlink" title="二、逻辑表达式"></a>二、逻辑表达式</h5><p>逻辑运算符：<br>    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false。<br>    or (||)：两个条件只要有一个成立，结果为true，否则为false。<br>    not  (!)：如果条件成立，则not后为false，否则为true。</p>
<p>​    </p>
<h5 id="三、模糊查询"><a href="#三、模糊查询" class="headerlink" title="三、模糊查询"></a>三、模糊查询</h5><p>   %： 代替0个或多个任意字符。<br>    _ ：代替1个任意字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * From flower where name like &apos;_a%&apos;;</span><br><span class="line">#转义关键词  ESCAPE</span><br><span class="line">SELECT * From flower where name like &apos;_\_%&apos;;</span><br><span class="line">SELECT * From flower where name like &apos;_$_%&apos; ESCAPE &apos;$&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="四、关键字-between-and"><a href="#四、关键字-between-and" class="headerlink" title="四、关键字  between  and"></a>四、关键字  between  and</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#包含两头的数据 [ , ]</span><br><span class="line">SELECT * From emp where sal &gt;=200 and sal&lt;=300;</span><br><span class="line">#等价与</span><br><span class="line">SELECT * From emp where sal between 200 and 300;</span><br></pre></td></tr></table></figure>



<h5 id="五、关键字-in"><a href="#五、关键字-in" class="headerlink" title="五、关键字 in"></a>五、关键字 in</h5><p>含义:判断某字段的值是否属于in列表中的某一项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#格式</span><br><span class="line">in (目标值1，目标值2，...) -- in 中的内容只能为一个字段的值,目标值之间必须使用逗号分隔,并且括在括号中。</span><br><span class="line">SELECT * From emp where job in (&apos;Salesman&apos;,&apos;manager&apos;,&apos;analyst&apos;);</span><br></pre></td></tr></table></figure>



<h5 id="六、关键字-is-null-is-not-null"><a href="#六、关键字-is-null-is-not-null" class="headerlink" title="六、关键字  is null  , is not null"></a>六、关键字  is null  , is not null</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#格式 </span><br><span class="line">SELECT * FROM 表名 WHERE 字段名 is null; -- 字段值为Null</span><br><span class="line">SELECT * FROM 表名 WHERE 字段名 is not null; -- 字段值不为Null</span><br><span class="line">SELECT * FROM emp WHERE comm is not null; -- 字段值不为Null</span><br></pre></td></tr></table></figure>

<p>注意: 不能使用=,&lt;&gt;来判断NULL值。</p>
<h5 id="七、安全等于-lt-gt"><a href="#七、安全等于-lt-gt" class="headerlink" title="七、安全等于 &lt;=&gt;"></a>七、安全等于 &lt;=&gt;</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM flower WHERE production &lt;=&gt; null;</span><br></pre></td></tr></table></figure>

<p>is null : 仅仅可以判断NULL值，可读性高,建议使用。</p>
<p>&lt;=&gt; :  既可以判断NULL值,又可以判断普通数值，可读性较低。</p>
<hr>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">#单字段排序</span><br><span class="line">select 要查询的东西 from 表名 where 筛选条件 order by 排序的字段|表达式|函数|别名 [asc|desc]</span><br><span class="line"></span><br><span class="line">#多字段排序</span><br><span class="line">select 要查询的东西 from 表名 where 筛选条件 order by 字段名1 [asc|desc],字段名2 [asc|desc]...</span><br></pre></td></tr></table></figure>

<p>注意: </p>
<p>1.asc代表的是升序,desc代表的是降序,如果不写,默认为升序。</p>
<p>2.order by 子句中可以支持单个字段,多个字段,表达式,函数,别名。</p>
<p>3.order by 子句一般是放在查询语句的最后面,limit子句除外。</p>
<hr>
<h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><h5 id="一、单行函数"><a href="#一、单行函数" class="headerlink" title="一、单行函数"></a>一、单行函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用法</span><br><span class="line">SELECT 函数名() FROM 表名 WHERE 筛选条件</span><br><span class="line">1、字符函数</span><br><span class="line">	concat　拼接</span><br><span class="line">	substr　截取子串  -- 注意：索引从1开始</span><br><span class="line">	upper　转换成大写</span><br><span class="line">	lower　转换成小写</span><br><span class="line">	trim　去前后指定的空格和字符</span><br><span class="line">	ltrim　去左边空格</span><br><span class="line">	rtrim　去右边空格</span><br><span class="line">	replace　替换</span><br><span class="line">	lpad　用指定的字符实现左填充指定长度</span><br><span class="line">	rpad　用指定的字符实现右填充指定长度</span><br><span class="line">	instr　返回子串第一次出现的索引 -- 如果找不到返回0</span><br><span class="line">	length 获取字节个数</span><br><span class="line"></span><br><span class="line">2、数学函数</span><br><span class="line">	round 四舍五入</span><br><span class="line">	rand 随机数</span><br><span class="line">	floor 向下取整 -- &lt;=该参数的最大整数</span><br><span class="line">	ceil 向上取整  -- &gt;=该参数的最小整数</span><br><span class="line">	mod 取余</span><br><span class="line">	truncate 截断</span><br><span class="line">	</span><br><span class="line">3、日期函数</span><br><span class="line">	now 当前系统日期+时间</span><br><span class="line">	curdate 当前系统日期</span><br><span class="line">	curtime 当前系统时间</span><br><span class="line">	str_to_date 将字符转换成日期</span><br><span class="line">	date_format  将日期转换成字符</span><br><span class="line">	DATEDIFF 求两个日期相差的天数 </span><br><span class="line">	SELECT DATEDIFF(now(),&quot;1998-05-27&quot;) </span><br><span class="line">	</span><br><span class="line">4、流程控制函数</span><br><span class="line">	#if 处理双分支 -- if else的效果</span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct is null,&apos;没奖金,呵呵&apos;,&apos;有奖金,嘻嘻&apos;) 备注 FROM employees;</span><br><span class="line"></span><br><span class="line">	#case语句 </span><br><span class="line">	#1.类似 switch-case的效果</span><br><span class="line">	case 要判断的字段或表达式</span><br><span class="line">    when 常量1 then 要显示的值1或者语句1;</span><br><span class="line">    when 常量2 then 要显示的值2或者语句2;</span><br><span class="line">    ...</span><br><span class="line">    else 要显示的值n或者语句n;</span><br><span class="line">    end</span><br><span class="line">    #例子</span><br><span class="line">	SELECT salary 原始工资,department_id,</span><br><span class="line">    CASE department_id</span><br><span class="line">      WHEN 30 THEN salary*1.1</span><br><span class="line">      WHEN 40 THEN salary*1.2</span><br><span class="line">      WHEN 50 THEN salary*1.3</span><br><span class="line">      ELSE salary</span><br><span class="line">    END AS 新工资  FROM employees</span><br><span class="line">    </span><br><span class="line">    #2.类似 多重if</span><br><span class="line">    case </span><br><span class="line">    when 条件1 then 要显示的值1或者语句1;</span><br><span class="line">    when 条件2 then 要显示的值2或者语句2;</span><br><span class="line">    ...</span><br><span class="line">    else 要显示的值n或者语句n;</span><br><span class="line">    end</span><br><span class="line">    #例子</span><br><span class="line">    SELECT salary ,</span><br><span class="line">    CASE </span><br><span class="line">     WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">     WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">     WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">     ELSE &apos;D&apos;</span><br><span class="line">    END AS 工资级别 FROM employees</span><br><span class="line">    </span><br><span class="line">5、其他函数</span><br><span class="line">	version 版本</span><br><span class="line">	database 当前库</span><br><span class="line">	user 当前连接用户</span><br><span class="line">	md5(&apos;字符&apos;) 返回该字符的md5加密形式 </span><br><span class="line">	datediff(大的日期，小的日期) 返回两个日期的时间差</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h5 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计算个数</span><br></pre></td></tr></table></figure>

<p>特点：<br><em>1、*sum,max,min,avg,count(字段名)都忽略null值，count(</em> )不忽略null值。<br>2、sum和 avg一般用于处理数值型；max、min、count可以处理任何数据类型。<br>3、都可以搭配distinct使用，用于统计去重后的结果。<br>4、count的参数可以支持：字段、常量值、* ，一般放1,建议使用 count(*)。</p>
<p>效率：</p>
<p>MyISAM存储引擎下,count(*)的效率高。</p>
<p>InnoDB存储引擎下,count(*)和count(1)的效率差不多，比count(字段名)要高一些。</p>
<hr>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">#分组前的筛选</span><br><span class="line">select 查询的字段，分组函数</span><br><span class="line">from 表名</span><br><span class="line">[where 筛选条件]</span><br><span class="line">group by 分组的字段</span><br><span class="line">[order by 子句]</span><br><span class="line"></span><br><span class="line">#分组后的筛选 having 子句</span><br><span class="line">-- 查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line">select MAX(salary),job_id from employees where commission_pct is not null</span><br><span class="line">group by job_id having MAX(salart)&gt;12000;</span><br><span class="line"></span><br><span class="line">-- 按员工姓名的长度分组,查询每一组的员工个数，筛选员工个数&gt;5</span><br><span class="line">select count(*) c,LENGTH(last_name) len_name from employees </span><br><span class="line">group by len_name having c&gt;5;</span><br><span class="line">#group by,having后可以支持别名。</span><br></pre></td></tr></table></figure>

<p>特点：<br>1、支持按单个字段分组;也可以按多个字段分组,多个字段之间用逗号隔开,没有顺序要求;表达式或函数(用得较少)。<br>2、和分组函数一同查询的字段最好是分组后的字段。<br>3、分组筛选<br>针对的表             位置            关键字<br>分组前筛选：    原始表        group by的前面        where<br>分组后筛选：    分组后的结果集    group by的后面        having</p>
<p>分组函数做条件肯定是放在having子句中。</p>
<p>4.查询列表必须特殊,要求是分组函数和group by后出现的字段。</p>
<hr>
<h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><h5 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a><strong>一、分类</strong></h5><p>按年代分类：</p>
<p>sql92标准，sql99标准</p>
<p>按功能分类:</p>
<p>内连接：等值连接,非等值连接,自连接</p>
<p>外连接：左外连接,右外连接,全外连接</p>
<p>交叉连接</p>
<h5 id="二、笛卡尔乘积"><a href="#二、笛卡尔乘积" class="headerlink" title="二、笛卡尔乘积"></a><strong>二、笛卡尔乘积</strong></h5><p>表1有m行，表2有n行,结果为m*n行。<br>解决办法：添加上有效的连接条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp,dept;</span><br></pre></td></tr></table></figure>



<h5 id="三、sql92标准"><a href="#三、sql92标准" class="headerlink" title="三、sql92标准"></a><strong>三、sql92标准</strong></h5><p>含义：1992年推出的sql语法。</p>
<p>仅仅支持内连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.等值连接 先做笛卡尔积，然后筛选,筛选条件为等值筛选。</span><br><span class="line">select e.ename,e.job,d.dname from emp e,dept d where e.deptno = d.deptno;</span><br><span class="line">/*</span><br><span class="line">1.多表等值连接的结果为多表的交集部分。</span><br><span class="line">2.n表连接，至少需要n-1个连接条件。</span><br><span class="line">3.多表的顺序没有要求，一般需要为表起别名。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#2.非等值连接</span><br><span class="line">select * from emp e,sqlgrade s where e.sal&gt;=s.losal and e.sal&lt;=s.hisal;</span><br><span class="line"></span><br><span class="line">#3.自连接</span><br><span class="line">-- 查询员工姓名,工作,薪资,及上级领导的姓名</span><br><span class="line">select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr=e2.empno;</span><br></pre></td></tr></table></figure>



<h5 id="四、sql99标准-推荐使用"><a href="#四、sql99标准-推荐使用" class="headerlink" title="四、sql99标准[推荐使用]"></a>四、sql99标准[推荐使用]</h5><p>含义：1999年推出的sql语法。<br>支持：内连接,外连接(左外连接，右外连接),交叉连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">【inner|left [outer]|right [outer]|cross】join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 内连接</span><br><span class="line">#1.等值连接</span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">[inner] join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">[where 筛选条件]</span><br><span class="line"></span><br><span class="line">select e.ename,e.job,d.dname </span><br><span class="line">from emp e</span><br><span class="line">inner join dept d </span><br><span class="line">on e.deptno = d.deptno</span><br><span class="line">where e.deptno=1001;</span><br><span class="line">/*</span><br><span class="line">1.inner可以省略。</span><br><span class="line">2.连接条件放在on后面,筛选条件放在where后面,提高分离性,便于阅读。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#2.非等值连接</span><br><span class="line">select * </span><br><span class="line">from emp e</span><br><span class="line">inner join sqlgrade s </span><br><span class="line">on e.sal&gt;=s.losal and e.sal&lt;=s.hisal;</span><br><span class="line"></span><br><span class="line">#3.自连接</span><br><span class="line">select e1.ename,e1.job,e1.sal,e2.ename </span><br><span class="line">from emp e1</span><br><span class="line">inner join emp e2 </span><br><span class="line">on e1.mgr=e2.empno;</span><br><span class="line"></span><br><span class="line">-- 外连接</span><br><span class="line">#应用场景:用于查询一个表中有，另一个表没有的记录。</span><br><span class="line">/*</span><br><span class="line">特点：</span><br><span class="line">1.外连接的查询结果为主表中的所有记录</span><br><span class="line">  如果从表中有和它匹配的,则显示匹配的值。</span><br><span class="line">  如果从表中没有和它匹配的,则显示null。</span><br><span class="line">  外连接查询的结果=内连接+主表中有而从表没有的记录。</span><br><span class="line">2.左外连接：left join左边的是主表</span><br><span class="line">  右外连接：left join右边的是主表</span><br><span class="line">3.左外和右外交换两个表的顺序,可以实现同样的效果。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#1.左外连接与右外连接</span><br><span class="line">-- 左外连接</span><br><span class="line">select e.*,d.* </span><br><span class="line">from emp e</span><br><span class="line">left outer join dept d</span><br><span class="line">on e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">-- 右外连接</span><br><span class="line">select e.*,d.* </span><br><span class="line">from emp e</span><br><span class="line">right outer join dept d</span><br><span class="line">on e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">#2.交叉连接 本质就是笛卡尔积</span><br><span class="line">select e.*,d.* from emp e</span><br><span class="line">cross join dept d</span><br><span class="line">on e.deptno=d.deptno;</span><br></pre></td></tr></table></figure>



<p><strong>五、sql92 与 sql99的比较</strong></p>
<p>功能：sql99支持的较多。</p>
<p>可读性：sql99实现连接条件和筛选条件的分离,可读性较高。</p>
<p>推荐性: 建议使用sql99。</p>
<hr>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：</p>
<p>​    一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询;在外面的查询语句，称为主查询或外查询。</p>
<p>分类：</p>
<p>按子查询出现的位置：     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 后面：</span><br><span class="line">	仅仅支持标量子查询</span><br><span class="line">from 后面:</span><br><span class="line">	支持表子查询</span><br><span class="line">where或having后面:</span><br><span class="line">	标量子查询 (单行子查询)</span><br><span class="line">	列子查询   (多行子查询)</span><br><span class="line">	行子查询   (多列多行)</span><br><span class="line">exists 后面 (相关子查询)</span><br><span class="line">       表子查询</span><br></pre></td></tr></table></figure>

<p>按结构集的行列数不同:<br>           标量子查询（结果集只有一行一列）</p>
<p>​           列子查询    （结果集只有一列多行）</p>
<p>​           行子查询    （结果集有一行多列）    </p>
<p>​           表子查询      (结果集一般为多行多列）    </p>
<p>特点：</p>
<p>1、子查询都放在小括号内<br>2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧<br>3、子查询优先于主查询执行，主查询使用了子查询的执行结果<br>4、子查询根据查询结果的行数不同分为以下两类：<br>① 单行子查询<br>    结果集只有一行<br>    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=<br>    非法使用子查询的情况：<br>    a、子查询的结果为一组值<br>    b、子查询的结果为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 标量子查询</span><br><span class="line">-- 查询工资比Tom高的员工信息</span><br><span class="line">select *</span><br><span class="line">form emp</span><br><span class="line">where sal&gt;(</span><br><span class="line">			select sal</span><br><span class="line">    		from emp </span><br><span class="line">    		where ename = &apos;Tom&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询最低工资大于50号的最低工资的部门编号和其最低工资。</span><br><span class="line">select min(sal),deptno</span><br><span class="line">from emp </span><br><span class="line">group by deptno</span><br><span class="line">having min(sal)&gt;(</span><br><span class="line">    			select min(sal) </span><br><span class="line"> 				from emp </span><br><span class="line">				where deptno=50</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>② 多行子查询<br>    结果只有一个字段但是字段有n个值。</p>
<p>​    一般搭配多行操作符使用：any、all、in、not in。</p>
<p>​    any:    任意</p>
<p>​    all:    所有</p>
<p>​    in：表示任意存在，相当于=any。</p>
<p>​    not in :相当于&lt;&gt; all。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关键字 any</span><br><span class="line">-- 查询工资高于任意一个CLERK的所有员工信息。</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where sal &gt; any(</span><br><span class="line">				select sal</span><br><span class="line">    			from emp </span><br><span class="line">    			where job=&apos;CLERK&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#关键词 all</span><br><span class="line">-- 查询工资高于所有SALESMAN的员工信息。</span><br><span class="line">select * </span><br><span class="line">from emp </span><br><span class="line">where sal &gt; all(</span><br><span class="line">				select sal</span><br><span class="line">    			from emp </span><br><span class="line">    			where job=&apos;SALESMAN&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#关键词 in</span><br><span class="line">-- 查询部门号20中同部门10的雇员工作一样的雇员信息。</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where job in (</span><br><span class="line">			 select job</span><br><span class="line">    		 from emp </span><br><span class="line">    		 where deptno=10</span><br><span class="line">) and deptno =20;</span><br><span class="line">-- 等价于</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where job = any(</span><br><span class="line">			 select job</span><br><span class="line">    		 from emp </span><br><span class="line">    		 where deptno=10</span><br><span class="line">) and deptno =20;</span><br></pre></td></tr></table></figure>

<p>行子查询 (使用频率少)</p>
<p>​    结果集一行多列或者多行多列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工编号最小并且工资最高的员工信息。</span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where empno = (</span><br><span class="line">				select min(empno)</span><br><span class="line">    			from emp</span><br><span class="line">)  and sal = (</span><br><span class="line">    			select max(sal)</span><br><span class="line">    			from emp</span><br><span class="line">);</span><br><span class="line">-- 等价于</span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where (empno,sal) = (</span><br><span class="line">					select min(empno),max(sal)</span><br><span class="line">    				from emp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>from后面的子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">-- 将子查询结果充当一张表,要求必须起别名</span><br><span class="line">select avg_dep.*,s.grade</span><br><span class="line">from (</span><br><span class="line">	 select avg(sal) avg,deptno</span><br><span class="line">     from emp </span><br><span class="line">     group by deptno</span><br><span class="line">) avg_dep</span><br><span class="line">inner join salgrade s</span><br><span class="line">on avg_dep.avg between losal and hisal;</span><br></pre></td></tr></table></figure>

<p>exists后面的子查询 （相关子查询）</p>
<p>EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值true或false,结果为1或0。</p>
<p>语法: exists (完整的查询语句)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询有员工的部门名</span><br><span class="line">select d.dname </span><br><span class="line">from dept d</span><br><span class="line">where exists (</span><br><span class="line">			select *</span><br><span class="line">    		from emp e</span><br><span class="line">     		where d.deptno =e.deptno   		</span><br><span class="line">);</span><br><span class="line">-- 等价于</span><br><span class="line">select d.dname </span><br><span class="line">from dept d</span><br><span class="line">where d.deptno in (</span><br><span class="line">			select deptno</span><br><span class="line">    		from emp     				</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>应用场景：</p>
<p>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1.起始条目索引从0开始。</p>
<p>2.limit子句放在查询语句的最后</p>
<p>3.公式：select * from  表 limit （page-1）*size,size<br>每页显示条目数size<br>要显示的页数 page</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询前五条员工的信息</span><br><span class="line">select * from emp limit 0,5;</span><br><span class="line">select * from emp limit 5;</span><br><span class="line"></span><br><span class="line">#查询第11条-第25条</span><br><span class="line">select * from emp 10,15;</span><br><span class="line"></span><br><span class="line">#有奖金的员工信息,并且工资较高的前10名显示出来</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where comm is not null</span><br><span class="line">order by sal desc</span><br><span class="line">limit 0,10;</span><br></pre></td></tr></table></figure>



<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>引入：<br>    union 联合、合并：将多条查询语句的结果合并成一个结果。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1、多条查询语句的查询的列数必须是一致的。<br>2、多条查询语句的查询的列的类型几乎相同。<br>3、union代表去重，union all代表不去重。</p>
<p>应用场景：</p>
<p>要查询的结果来自于多个表，且多个表没有直接的连接关系,但查询的信息一致时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">select id,cname,csex from t_ca where csex =&apos;男&apos;</span><br><span class="line">union</span><br><span class="line">select t_id,tname from t_ua where tGender=&apos;male&apos;;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DML语言的学习"><a href="#DML语言的学习" class="headerlink" title="DML语言的学习"></a>DML语言的学习</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">-- 方式一 支持插入多行，支持子查询</span><br><span class="line">	insert into 表名(字段名，...) values(值1，...);</span><br><span class="line">-- 方式二 </span><br><span class="line">	insert into 表名 set 列名1=值1,列名2=值2...;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1、字段类型和值类型一致或兼容，而且一一对应。<br>2、可以为空的字段，可以不用插入值，或用null填充。<br>3、不可以为空的字段，必须插入值。<br>4、字段个数和值的个数必须一致。<br>5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一支持插入多行</span><br><span class="line">insert into beauty</span><br><span class="line">values(1603,&apos;尹远洋&apos;,&apos;男&apos;,23),(1604,&apos;张三&apos;,&apos;男&apos;,21),(1605,&apos;李丽&apos;,&apos;女&apos;,18);</span><br><span class="line"></span><br><span class="line">#支持子查询</span><br><span class="line">insert into beauty(id,name,age) select 1603,&apos;尹远洋&apos;,23;</span><br></pre></td></tr></table></figure>



<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>修改单表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段=新值,字段=新值 where 筛选条件;</span><br></pre></td></tr></table></figure>

<p>修改多表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sql92语法</span><br><span class="line">update 表1 别名1,表2 别名2</span><br><span class="line">set 字段=新值，字段=新值</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">#sql99语法</span><br><span class="line">update 表1 别名1</span><br><span class="line">inner|left|right join 表2 别名2</span><br><span class="line">on 连接条件</span><br><span class="line">set 字段=新值，字段=新值</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="方式1：delete语句"><a href="#方式1：delete语句" class="headerlink" title="方式1：delete语句"></a>方式1：delete语句</h5><p>单表的删除： ★</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 [where 筛选条件];</span><br></pre></td></tr></table></figure>

<p>多表的删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sql92语法</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br><span class="line">	</span><br><span class="line">#sql99语法</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1</span><br><span class="line">	inner|left|right join 表2 别名2</span><br><span class="line">	on 连接条件</span><br><span class="line">	where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="方式2：truncate语句"><a href="#方式2：truncate语句" class="headerlink" title="方式2：truncate语句"></a>方式2：truncate语句</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<p>两种方式的区别【面试题】</p>
<p>1.truncate不能加where条件，而delete可以加where条件。</p>
<p>2.truncate的效率高一丢丢。</p>
<p>3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始；<br>delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。</p>
<p>4.truncate删除没有返回值，delete删除有返回值。</p>
<p>4.truncate删除不能回滚，delete删除可以回滚。</p>
<hr>
<h3 id="DDL语言的学习"><a href="#DDL语言的学习" class="headerlink" title="DDL语言的学习"></a>DDL语言的学习</h3><h4 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h4><h5 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建库</span><br><span class="line">create database [if not exists] 库名;</span><br><span class="line">#修改库 </span><br><span class="line">-- 目前不能用了,不安全</span><br><span class="line">#更改库的字符集</span><br><span class="line">alter database 库名 character set 字符集;</span><br><span class="line">#删除库</span><br><span class="line">drop database [if exists] 库名;</span><br></pre></td></tr></table></figure>



<h5 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建表</span><br><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">	列名 列的类型[(长度) 约束],</span><br><span class="line">    列名 列的类型[(长度) 约束],</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	stuId INT,</span><br><span class="line">	stuName VARCHAR(20),</span><br><span class="line">	gender CHAR,</span><br><span class="line">	bornDate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改表 alter</span><br><span class="line">语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br><span class="line"></span><br><span class="line">#①修改字段名</span><br><span class="line">ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;</span><br><span class="line"></span><br><span class="line">#②修改表名</span><br><span class="line">ALTER TABLE stuinfo RENAME [TO] studentinfo;</span><br><span class="line"></span><br><span class="line">#③修改字段类型和列级约束</span><br><span class="line">ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</span><br><span class="line"></span><br><span class="line">#④添加字段</span><br><span class="line">ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20);</span><br><span class="line"></span><br><span class="line">#⑤删除字段</span><br><span class="line">ALTER TABLE studentinfo DROP COLUMN email;</span><br><span class="line"></span><br><span class="line">#删除表</span><br><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br><span class="line"></span><br><span class="line">#表的复制</span><br><span class="line">-- 1.仅仅复制表的结构</span><br><span class="line">create table 表名 like 表名;</span><br><span class="line"></span><br><span class="line">-- 2.复制表的结构+数据</span><br><span class="line">create table 新表 select * from 旧表;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h4><p>整型：<br>    tinyint、smallint、mediumint、int/Integer、bigint<br>小数：<br>    浮点型: float、double<br>    定点型:dec(M,D)、decimal(M,D)</p>
<p>​    特点：</p>
<p>​    1.M：整数部位+小数部位</p>
<p>​    D:小数部位</p>
<p>​    如果超过范围，则插入临界值。</p>
<p>​    2.M和D都可以省略，如果是decimal，则M默认为10,D默认为0。</p>
<p>​    如果是float和double,则会根据插入的数值的精度来决定精度。</p>
<p>​    3.定点型的精确度较高,如果要求插入数值的精度较高如货币运算等则考虑使用。</p>
<p>字符型：</p>
<p>较短的文本:char 、varchar</p>
<p>较长的文本:text、blob(较大的二进制)</p>
<table>
<thead>
<tr>
<th></th>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>char(M)</td>
<td>最大的字符数,可以省略,默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar</td>
<td>varchar(M)</td>
<td>最大的字符数,不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody></table>
<p>其他：</p>
<p>binary和varbinary用于保存较短的二进制。</p>
<p>enum用于保存枚举。</p>
<p>set用于保存集合。</p>
<p>日期型：</p>
<p>分类：</p>
<p>​    data:只保存日期</p>
<p>​    time:只保存时间</p>
<p>​    year:只保存年</p>
<p>​    datetime:保存日期+时间</p>
<p>​    timestamp:保存日期+时间</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区等的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<p>Blob类型：</p>
<p>​        ·tinyblob:仅255个字符<br>　　·blob:最大限制到65K字节<br>　　·mediumblob:限制到16M字节<br>　　·longblob:可达4GB</p>
<h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOT NULL:非空,用来保证该字段的值不能为空</span><br><span class="line">DEFAULT:默认,用于保证该字段有默认值</span><br><span class="line">UNIQUE:唯一,用于保证该字段的值具有唯一性,可以为空</span><br><span class="line">CHECK:检查约束  [mysql中不支持]</span><br><span class="line">PRIMARY KEY:主键,用于保证该字段的值具有唯一性,并且非空</span><br><span class="line">FOREIGN KEY:外键,用于限制两个表的关系,用于保证该字段的值必须来自于主表的关联列的值</span><br><span class="line">在从表添加外键约束,用于引用主表中某列的值</span><br></pre></td></tr></table></figure>

<p>添加约束的时机：</p>
<p>​        1.创建表时</p>
<p>​        2.修改表时</p>
<p>约束的添加分类：</p>
<p>​            列级约束：</p>
<p>​                        六大约束语法上都支持,但是外键约束没有效果</p>
<p>​            表级约束：</p>
<p>​                        除了非空,默认,其他的都支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名 字段类型 列级约束,</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	表级约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>列级约束</p>
<p>语法：直接在字段名和类型后面追加约束类型即可。</p>
<p>只支持:默认,非空,主键,唯一。</p>
<p>表级约束</p>
<p>支持：主键,外键,唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[constraint 约束名] 约束类型(字段名);</span><br><span class="line">constraint pk PRIMARY KEY(id), #主键约束</span><br><span class="line">UNIQUE(seat), #唯一键</span><br><span class="line">constraint fk_stuinfo_major FOREIGN KEY(majorid) references major(id)  #外键约束</span><br></pre></td></tr></table></figure>



<p>主键和唯一的区别:</p>
<table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可以有多少个</th>
<th>是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>√</td>
<td>×</td>
<td>至多有一个</td>
<td>√，但不推荐</td>
</tr>
<tr>
<td>唯一</td>
<td>√</td>
<td>√</td>
<td>可以有多个</td>
<td>√，但不推荐</td>
</tr>
</tbody></table>
<p>外键：</p>
<p>1.要求在从表设置外键关系。</p>
<p>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称没要求。</p>
<p>3.主表的关联列必须是一个key（一般是主键或者唯一)。</p>
<p>4.插入数据时,先插入主表,再插入从表。<br>删除数据时,先删除从表,再删除主表。</p>
<p>修改表时添加约束</p>
<p>1.添加列级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br></pre></td></tr></table></figure>

<p>2.添加表级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用];</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加非空约束</span><br><span class="line">alter table stuinfo modify column stuname varchar(20) not null;</span><br><span class="line">#添加默认约束</span><br><span class="line">alter table stuinfo modify column age int  default 18;</span><br><span class="line">#添加主键</span><br><span class="line">-- 列级约束</span><br><span class="line">alter table stuinfo modify column id  int primary key;</span><br><span class="line">-- 表级约束</span><br><span class="line">alter table stuinfo add primary key(id);</span><br><span class="line">#添加唯一</span><br><span class="line">-- 列级约束</span><br><span class="line">alter table stuinfo modify column seat int unique;</span><br><span class="line">-- 表级约束</span><br><span class="line">alter table stuinfo add unique(seat);</span><br><span class="line">#添加外键</span><br><span class="line">-- 表级约束</span><br><span class="line">alter table stuinfo add constraint fk_stuinfo_major foreign key(majorid) references major(id);</span><br></pre></td></tr></table></figure>



<p>修改表时删除约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除非空约束</span><br><span class="line">alter table stuinfo modify column stuname varchar(20)  null;</span><br><span class="line">#删除默认约束</span><br><span class="line">alter table stuinfo modify column age int ;</span><br><span class="line">#删除主键</span><br><span class="line">alter table stuinfo drop primary key;</span><br><span class="line">#删除唯一</span><br><span class="line">alter table stuinfo drop index seat;</span><br><span class="line">#删除外键</span><br><span class="line">alter table stuinfo drop foreign key fk_stuinfo_major;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列的下面</td>
<td>默认和非空不支持,其他支持</td>
<td>可以(主键没有效果)</td>
</tr>
</tbody></table>
<p>标识列</p>
<p>又称为自增长列。含义：可以不用手动的插入值，系统提供默认的序列值。</p>
<p>特点:</p>
<p>1.标识列要求是一个key。</p>
<p>2.一个表至多一个标识列。</p>
<p>3.标识列的类型只能是数值型。</p>
<p>4.标识列可以通过set auto_increment_increment=数字；设置步长</p>
<p>可以通过手动插入值 ,设置起始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>修改表时设置标识列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user modify column id int primary key auto_increment;</span><br></pre></td></tr></table></figure>

<p>删除表时设置标识列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user modify column id int;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><h4 id="特点-ACID"><a href="#特点-ACID" class="headerlink" title="特点(ACID):"></a>特点(ACID):</h4><p>​    原子性（Atomicity）：一个事务不可再分割,要么都执行要么都不执行。<br>​    一致性(Consistency)：一个事务保证数据的状态操作前和操作后保持一致。<br>​    隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。<br>​    持久性(Durability)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。</p>
<h4 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h4><p>隐式事务，没有明显的开启和结束事务的标志。</p>
<p>比如insert、update、delete语句本身就是一个事务。</p>
<p>显式事务，具有明显的开启和结束事务的标志。</p>
<p>前提：必须先设置自动提交功能为禁用。</p>
<p>set autocommit=0;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#步骤1:开启事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction; #可选的</span><br><span class="line">	</span><br><span class="line">#步骤2.编写事务的一组逻辑操作单元（多条sql语句）</span><br><span class="line">	select</span><br><span class="line">	insert</span><br><span class="line">	update</span><br><span class="line">	delete	</span><br><span class="line">	</span><br><span class="line">#步骤3.提交事务或回滚事务</span><br><span class="line">	commit; 提交事务</span><br><span class="line">	rollback; 回滚事务</span><br></pre></td></tr></table></figure>

<h4 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">start transaction;</span><br><span class="line">commit;</span><br><span class="line">rollback;</span><br><span class="line">savepoint  断点</span><br><span class="line">commit to 断点</span><br><span class="line">rollback to 断点</span><br><span class="line"></span><br><span class="line">#演示savepoint的使用</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction;</span><br><span class="line">delete from account where id=25;</span><br><span class="line">savepoint a;-- 设置保持点a</span><br><span class="line">delete from account where id=28;</span><br><span class="line">rollback to a; -- 回滚到保持点a</span><br></pre></td></tr></table></figure>





<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><h5 id="事务并发问题如何发生"><a href="#事务并发问题如何发生" class="headerlink" title="事务并发问题如何发生"></a>事务并发问题如何发生</h5><p>当多个事务同时操作同一个数据库的相同数据时。</p>
<h5 id="事务的并发问题有哪些"><a href="#事务的并发问题有哪些" class="headerlink" title="事务的并发问题有哪些"></a>事务的并发问题有哪些</h5><h5 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h5><p>脏读是指并发过程中，一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update account set money=money+100 where name=’B’;  (此时A通知B)</span><br><span class="line"></span><br><span class="line">update account set money=money - 100 where name=’A’;</span><br></pre></td></tr></table></figure>

<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h5 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h5><p>　　不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。</p>
<h5 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h5><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1查询<strong>整张表</strong>中有多少条记录，这时事务T2又对这个表中插入了一行数据。而操作事务T1的用户如果再查看整张表有多少行数据，会发现多出一行数据，其实这行是事务T2添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<h5 id="不可重复读和脏读的区别是"><a href="#不可重复读和脏读的区别是" class="headerlink" title="不可重复读和脏读的区别是:"></a>不可重复读和脏读的区别是:</h5><p>脏读是某一事务读取了另一个事务未提交的脏数据。</p>
<p>不可重复读则是两次读取之间存在另一个事务提交的数据。</p>
<p>　　</p>
<p><strong>幻读和不可重复读区别是：</strong></p>
<ul>
<li><p>不可重复读的重点是修改（update），操作的是某一行数据，需要锁行。同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。</p>
</li>
<li><p>幻读的重点在于新增（insert）或者删除（delete），操作的是整张表，需要锁表。同样的条件, 第1次和第2次读出来的记录数不一样。</p>
</li>
</ul>
<h5 id="如何避免事务的并发问题"><a href="#如何避免事务的并发问题" class="headerlink" title="如何避免事务的并发问题"></a>如何避免事务的并发问题</h5><p>通过设置事务的隔离级别:<br>1、READ UNCOMMITTED（读未提交）<br>2、READ COMMITTED（读已提交） 可以避免脏读<br>3、REPEATABLE READ（可重复读） 可以避免脏读、不可重复读和一部分幻读  (默认)<br>4、SERIALIZABLE  (串行化) 可以避免脏读、不可重复读和幻读</p>
<h5 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure>

<h5 id="查看隔离级别"><a href="#查看隔离级别" class="headerlink" title="查看隔离级别"></a>查看隔离级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure>



<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>含义：理解成一张虚拟的表。</p>
<p>视图和表的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>使用方式</th>
<th></th>
<th>占用物理空间</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>增删改查，一般不做增删改</td>
<td>create view</td>
<td>不占用，仅仅保存的是sql逻辑</td>
</tr>
<tr>
<td>表</td>
<td>增删改查</td>
<td>create table</td>
<td>占用</td>
</tr>
</tbody></table>
<p>视图的好处：</p>
<p>1、sql语句提高重用性，简化复杂的sql操作，效率高。<br>2、和表实现了分离，保护数据,提高了安全性。</p>
<h4 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW  视图名</span><br><span class="line">	AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>



<h5 id="视图中数据增删改查"><a href="#视图中数据增删改查" class="headerlink" title="视图中数据增删改查"></a>视图中数据增删改查</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1、查看视图的数据 ★</span><br><span class="line">SELECT * FROM my_v4;</span><br><span class="line">SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;</span><br><span class="line"></span><br><span class="line">#一般不更改视图里面的数据</span><br><span class="line">#2、插入视图的数据</span><br><span class="line">INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);</span><br><span class="line"></span><br><span class="line">#3、修改视图的数据</span><br><span class="line">UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;</span><br><span class="line"></span><br><span class="line">#4、删除视图的数据</span><br><span class="line">DELETE FROM my_v4;</span><br></pre></td></tr></table></figure>



<h5 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h5><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p>
<h5 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">CREATE OR REPLACE VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE employee_id&gt;100;</span><br><span class="line"></span><br><span class="line">#方式二:</span><br><span class="line">ALTER VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id FROM employees;</span><br></pre></td></tr></table></figure>

<h5 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure>

<h5 id="视图的查看"><a href="#视图的查看" class="headerlink" title="视图的查看"></a>视图的查看</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式1</span><br><span class="line">DESC test_v7;</span><br><span class="line">#方式2</span><br><span class="line">SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure>







<h3 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h3><p>FROM –&gt; ON –&gt; JOIN –&gt; Where –&gt; group by –&gt; having –&gt; select –&gt; distinct –&gt; order by –&gt; limit</p>
]]></content>
  </entry>
</search>
