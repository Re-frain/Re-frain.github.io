<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring</title>
    <url>/2019/11/30/Spring/</url>
    <content><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="第1章-Spring概述"><a href="#第1章-Spring概述" class="headerlink" title="第1章 Spring概述"></a>第1章 Spring概述</h2><h3 id="1-1-Spring概述"><a href="#1-1-Spring概述" class="headerlink" title="1.1 Spring概述"></a>1.1 Spring概述</h3><ol>
<li>Spring 是一个开源框架。</li>
<li>Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能。</li>
<li>Spring 是一个 IOC(DI) 和 AOP 容器框架。</li>
</ol>
<p>具体描述 Spring:</p>
<ol>
<li>轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API</li>
<li>依赖注入(DI — dependency injection、IOC)</li>
<li>面向切面编程(AOP — aspect oriented programming)</li>
<li>容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期</li>
<li>框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象</li>
<li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC）</li>
</ol>
<h3 id="1-2-Spring模块"><a href="#1-2-Spring模块" class="headerlink" title="1.2  Spring模块"></a>1.2  Spring模块</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574990699897.png" alt="1574990699897"></p>
<h2 id="第2章-IOC容器和Bean的配置"><a href="#第2章-IOC容器和Bean的配置" class="headerlink" title="第2章 IOC容器和Bean的配置"></a>第2章 IOC容器和Bean的配置</h2><h3 id="2-1-IOC和DI"><a href="#2-1-IOC和DI" class="headerlink" title="2.1 IOC和DI"></a>2.1 IOC和DI</h3><h4 id="2-1-1-IOC-Inversion-of-Control"><a href="#2-1-1-IOC-Inversion-of-Control" class="headerlink" title="2.1.1 IOC(Inversion of Control)"></a>2.1.1 IOC(Inversion of Control)</h4><p>​    控制反转，所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</p>
<ol>
<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li>
<li><strong>控制什么</strong>：控制对象。</li>
<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>
</ol>
<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h4 id="2-1-2-DI-Dependency-Injection"><a href="#2-1-2-DI-Dependency-Injection" class="headerlink" title="2.1.2 DI(Dependency Injection)"></a>2.1.2 DI(Dependency Injection)</h4><p>​    IOC 的另一种表述方式：依赖注入,容器动态地将某个依赖关系注入到组件之中。</p>
<h4 id="2-1-3-关系"><a href="#2-1-3-关系" class="headerlink" title="2.1.3 关系"></a>2.1.3 关系</h4><p>​    其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<h4 id="2-1-4-IOC-容器在-Spring-中的实现"><a href="#2-1-4-IOC-容器在-Spring-中的实现" class="headerlink" title="2.1.4  IOC 容器在 Spring 中的实现"></a>2.1.4  <strong>IOC</strong> <strong>容器在</strong> <strong>Spring</strong> 中的实现</h4><p>在通过 IOC 容器读取 Bean 的实例之前，需要先将 IOC 容器本身实例化。 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用</p>
<p>Spring 提供了 IOC 容器的两种实现方式</p>
<h5 id="①-BeanFactory"><a href="#①-BeanFactory" class="headerlink" title="① BeanFactory"></a>① BeanFactory</h5><p>IOC 容器的基本实现，是 Spring 内部的基础设施，是面向 Spring 本身的，不是提供给开发人员使用的。 </p>
<h5 id="②-ApplicationContext"><a href="#②-ApplicationContext" class="headerlink" title="② ApplicationContext"></a>② ApplicationContext</h5><p>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的 使 用 者 ， 几 乎 所 有 场 合 都 使 用 ApplicationContext 而 不 是 底 层 的 BeanFactory 。 </p>
<p>ApplicationContext 的主要实现类：<br>1.ClassPathXmlApplicationContext：从类路径下加载配置文件。<br>2.FileSystemXmlApplicationContext:  从文件系统中加载配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext =<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力。</p>
<p>AanpplicationContext 在初始化上下文时就实例化所有单例的 Bean。<br>WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作。</p>
<p>​    </p>
<h3 id="2-2-从IOC容器中获取Bean"><a href="#2-2-从IOC容器中获取Bean" class="headerlink" title="2.2 从IOC容器中获取Bean"></a>2.2 从IOC容器中获取Bean</h3><p>​    从 IOC 容器中获取 bean 时，除了通过 id 值获取，还可以通过 bean 的类型获取。但如 果同一个类型的 bean 在 XML 文件中配置了多个，则获取时会抛出异常，所以同一个类型的 bean 在容器中必须是唯一的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = applicationContext.getBean(User.class);</span><br></pre></td></tr></table></figure>

<p>或者可以使用另外一个重载的方法，同时指定 bean 的 id 值和类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = applicationContext.getBean(<span class="string">"user"</span>,User.class);</span><br></pre></td></tr></table></figure>



<h3 id="2-3-依赖注入的方式-基于xml配置"><a href="#2-3-依赖注入的方式-基于xml配置" class="headerlink" title="2.3 依赖注入的方式(基于xml配置)"></a>2.3 依赖注入的方式(基于xml配置)</h3><h4 id="2-3-1-属性注入"><a href="#2-3-1-属性注入" class="headerlink" title="2.3.1 属性注入"></a>2.3.1 属性注入</h4><p>​    属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象。使用 &lt;property&gt; 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 &lt;value&gt; 子节点指定属性值 。属性注入是实际应用中最常用的注入方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类User</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	applicationContext.xml</span></span><br><span class="line"><span class="comment">	配置Bean</span></span><br><span class="line"><span class="comment">	class:bean的全类名,通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器</span></span><br><span class="line"><span class="comment">	id:标识容器中的Bean,在容器中必须是唯一的,若id没有指定,Spring自动将权限定性类名作为Bean的名字。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	property有三个参数:</span></span><br><span class="line"><span class="comment">	name:属性名,在实体bean中必须有对应的setter方法,否则报错。</span></span><br><span class="line"><span class="comment">	value:可以赋基本数据类型与String。</span></span><br><span class="line"><span class="comment">	ref:引用外部的bean。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"yinyuanyang"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-2-构造器注入"><a href="#2-3-2-构造器注入" class="headerlink" title="2.3.2 构造器注入"></a>2.3.2 构造器注入</h4><p>​    通过构造方法注入Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。不用为属性设置setter方法，但是需要有参构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类User</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	applicationContext.xml</span></span><br><span class="line"><span class="comment">	constructor-arg有5个参数:</span></span><br><span class="line"><span class="comment">	name:参数名</span></span><br><span class="line"><span class="comment">	value:可以赋基本数据类型与String</span></span><br><span class="line"><span class="comment">	index:参数的索引,从0开始</span></span><br><span class="line"><span class="comment">	ref:引用外部的bean</span></span><br><span class="line"><span class="comment">	type:类型(区分关键字与封装类 int Integer java.lang.String)  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"Yin"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-工厂方法注入"><a href="#2-3-3-工厂方法注入" class="headerlink" title="2.3.3 工厂方法注入"></a>2.3.3 工厂方法注入</h4><p>   不常用</p>
<h3 id="2-4-p命名空间"><a href="#2-4-p命名空间" class="headerlink" title="2.4 p命名空间"></a>2.4 p命名空间</h3><p>​    为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过 &lt;bean&gt; 元素属性的方式配置 Bean 的属性。使用 p 命名空间后，基于 XML 的配置方式将进一步简化。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span> <span class="attr">p:userId</span>=<span class="string">"1"</span> <span class="attr">p:userName</span>=<span class="string">"spring"</span> <span class="attr">p:password</span>=<span class="string">"123456"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-5-通过注解配置Bean"><a href="#2-5-通过注解配置Bean" class="headerlink" title="2.5 通过注解配置Bean"></a>2.5 通过注解配置Bean</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><p>​    相对于 XML 方式而言，通过注解的方式配置 bean 更加简洁和优雅，而且和 MVC 组件化开发的理念十分契合，是开发中常用的使用方式。</p>
<h4 id="2-5-2-使用注解标识组件"><a href="#2-5-2-使用注解标识组件" class="headerlink" title="2.5.2 使用注解标识组件"></a>2.5.2 使用注解标识组件</h4><p>1) 普通组件：@Component </p>
<p>标识一个受 Spring IOC 容器管理的组件,当不知道一些类归到哪个层时使用,但是不建议。</p>
<p>2) 持久化层组件：@Repository </p>
<p>标识一个受 Spring IOC 容器管理的持久化层组件。 </p>
<p>3) 业务逻辑层组件：@Service </p>
<p>标识一个受 Spring IOC 容器管理的业务逻辑层组件。 </p>
<p>4) 表述层控制器组件：@Controller </p>
<p>标识一个受 Spring IOC 容器管理的表述层控制器组件。</p>
<p>5) 组件命名规则 </p>
<p>​    ①默认情况：使用组件的<strong>简单类名首字母小写</strong>后得到的字符串作为 bean 的 id 。</p>
<p>​    ②使用组件注解的 value 属性指定 bean 的 id 。</p>
<p>注意：事实上 Spring 并没有能力识别一个组件到底是不是它所标记的类型，即使将 @Respository 注解用在一个表述层控制器组件上面也不会产生任何错误，所以 @Respository、@Service、@Controller 这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。</p>
<h4 id="2-5-3-扫描组件"><a href="#2-5-3-扫描组件" class="headerlink" title="2.5.3 扫描组件"></a>2.5.3 扫描组件</h4><p>组件被上述注解标识后还需要通过 Spring 进行扫描才能够侦测到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yyy.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详细说明: </p>
<p>①base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包及其子包中的所有类。</p>
<p>②当需要扫描多个包时可以使用逗号分隔。 </p>
<p>③如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类，示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.atguigu.component"</span> <span class="attr">resource-pattern</span>=<span class="string">"autowire/*.class"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>④包含与排除 </p>
<p>&lt;context:include-filter&gt;子节点表示要包含的目标类 </p>
<p>注意：通常需要与 use-default-filters 属性配合使用才能够达到“仅包含某些组件”这样的效果。即：通过将 use-default-filters 属性设置为 false,禁用默认过滤器，然后扫描的就只是 include-filter 中的规则指定的组件了。 </p>
<p>&lt;context:exclude-filter&gt;子节点表示要排除在外的目标类 。</p>
<p>&lt;component-scan&gt; 下可以拥有若干个 include-filter 和 exclude-filter 子节点。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575120562513.png" alt="1575120562513"></p>
<h3 id="2-6-可以使用的值"><a href="#2-6-可以使用的值" class="headerlink" title="2.6 可以使用的值"></a>2.6 可以使用的值</h3><h4 id="2-6-1-字面值"><a href="#2-6-1-字面值" class="headerlink" title="2.6.1 字面值"></a>2.6.1 字面值</h4><ol>
<li>可用字符串表示的值，可以通过 &lt;value&gt; 元素标签或 value 属性进行注入。</li>
<li>基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式</li>
<li>若字面值中包含特殊字符，可以使用&lt;![CDATA[]]&gt; 把字面值包裹起来。</li>
</ol>
<h4 id="2-6-2-null"><a href="#2-6-2-null" class="headerlink" title="2.6.2 null"></a>2.6.2 null</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-6-3-引用外部已声明的bean"><a href="#2-6-3-引用外部已声明的bean" class="headerlink" title="2.6.3 引用外部已声明的bean"></a>2.6.3 引用外部已声明的bean</h4><p>​    组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能。要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用。在 Bean 的配置文件中, 可以通过 &lt;ref&gt; 元素或 ref  属性为 Bean 的属性或构造器参数指定对 Bean 的引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Emp"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">ref</span>=<span class="string">"dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptno"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dname"</span>  <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-6-4-给bean的级联属性赋值"><a href="#2-6-4-给bean的级联属性赋值" class="headerlink" title="2.6.4 给bean的级联属性赋值"></a>2.6.4 给bean的级联属性赋值</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emp"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Emp"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"empno"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ename"</span> <span class="attr">value</span>=<span class="string">"yyy"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sal"</span> <span class="attr">value</span>=<span class="string">"2000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">ref</span>=<span class="string">"dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept.deptno"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-6-5-内部bean"><a href="#2-6-5-内部bean" class="headerlink" title="2.6.5 内部bean"></a>2.6.5 内部bean</h4><p>​    在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean。</p>
<p>​    当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 内部 Bean 声明直接包含在 &lt;property&gt; 或&lt;constructor-arg&gt; 元素里, 不需要设置任何 id 或 name 属性。内部 Bean 不能使用在任何其他地方。</p>
<h3 id="2-7-集合属性"><a href="#2-7-集合属性" class="headerlink" title="2.7 集合属性"></a>2.7 集合属性</h3><h4 id="2-7-1-数组与List"><a href="#2-7-1-数组与List" class="headerlink" title="2.7.1 数组与List"></a>2.7.1 数组与List</h4><p>​    配置 java.util.List 类型的属性, 需要指定 &lt;list&gt;  标签, 在标签里包含一些元素. 这些标签可以通过 &lt;value&gt; 指定简单的常量值, 通过&lt;ref&gt; 指定对其他 Bean 的引用,通过&lt;bean&gt; 指定内置 Bean 定义,通过 &lt;null/&gt; 指定空元素, 甚至可以内嵌其他集合。数组的定义和 List 一样, 都使用 &lt;list&gt;。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.User"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>唱<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>跳<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>rap<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-7-2-Set"><a href="#2-7-2-Set" class="headerlink" title="2.7.2 Set"></a>2.7.2 Set</h4><p>​    配置 java.util.Set 需要使用&lt;set&gt;标签，定义的方法与 List 一样。 </p>
<h4 id="2-7-3-Map"><a href="#2-7-3-Map" class="headerlink" title="2.7.3 Map"></a>2.7.3 Map</h4><p>​    Java.util.Map 通过&lt;map&gt; 标签定义, &lt;map&gt; 标签里可以使用多个 &lt;entry&gt; 作为子标签。每个条目包含一个键和一个值. 必须在 &lt;key&gt; 标签里定义键因为键和值的类型没有限制, 所以可以自由地为它们指定 &lt;value&gt;, &lt;ref&gt;, &lt;bean&gt; 或 &lt;null&gt; 元素. 可以将 Map 的键和值作为 &lt;entry&gt; 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"com.yyy.entity.Dept"</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"yyy"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--另一种写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yyy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 &lt;props&gt; 定义 java.util.Properties, 该标签使用多个 &lt;prop&gt; 作为子标签. 每个 &lt;prop&gt; 标签必须定义 key 属性。</p>
<h3 id="2-8-SpEL"><a href="#2-8-SpEL" class="headerlink" title="2.8 SpEL"></a>2.8 SpEL</h3><p>​    Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。</p>
<p>​    语法类似于 EL：<strong>SpEL 使用</strong> <strong>#{ } 作为定界符</strong>，所有在大框号中的字符都将被认为是 SpEL。SpEL 为 bean 的属性进行动态赋值提供了便利。通过 SpEL 可以实现：<br>​    1.通过 bean 的 id 对 bean 进行引用<br>​    2.调用方法以及引用对象中的属性<br>​    3.计算表达式的值<br>​    4.正则表达式的匹配</p>
<h4 id="2-8-1-字面量"><a href="#2-8-1-字面量" class="headerlink" title="2.8.1 字面量"></a>2.8.1 字面量</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">整数：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"count"</span> <span class="attr">value</span>=<span class="string">"#&#123;5&#125;"</span>/&gt;</span></span><br><span class="line">小数：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"frequency"</span> <span class="attr">value</span>=<span class="string">"#&#123;89.7&#125;"</span>/&gt;</span></span><br><span class="line">科学计数法：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"capacity"</span> <span class="attr">value</span>=<span class="string">"#&#123;1e4&#125;"</span>/&gt;</span></span><br><span class="line">String可以使用单引号或者双引号作为字符串的定界符号：</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;'Chuck'&#125;"</span>/&gt;</span> </span><br><span class="line">或 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">'name'</span> <span class="attr">value</span>=<span class="string">'#&#123;"Chuck"&#125;'</span>/&gt;</span></span><br><span class="line">Boolean：<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enabled"</span> <span class="attr">value</span>=<span class="string">"#&#123;false&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-8-2-引用-其他的Bean、属性和方法"><a href="#2-8-2-引用-其他的Bean、属性和方法" class="headerlink" title="2.8.2 引用 其他的Bean、属性和方法"></a>2.8.2 引用 其他的Bean、属性和方法</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">引用其他的Bean</span><br><span class="line"><span class="comment">&lt;!--之前的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">ref</span>=<span class="string">"dept"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 使用SpEL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">value</span>=<span class="string">"#&#123;dept&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引用其他对象的非静态属性</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptName"</span> <span class="attr">value</span>=<span class="string">"#&#123;dept.deptName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">调用非静态方法</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dept"</span> <span class="attr">value</span>=<span class="string">"#&#123;dept.toString()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">调用静态方法或静态属性(#&#123;T(类名).方法(属性)&#125;)</span><br><span class="line">通过 T() 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应的方法或属性。</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"circle"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(java.lang.Math).PI*20&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-8-3-运算符"><a href="#2-8-3-运算符" class="headerlink" title="2.8.3 运算符"></a>2.8.3 运算符</h4><p>1) 算术运算符：+、-、*、/、%、^ </p>
<p>2) 字符串连接：+ </p>
<p>3) 比较运算符：&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge </p>
<p>4) 逻辑运算符：and, or, not, |</p>
<p>5) 三目运算符：判断条件?判断结果为 true 时的取值:判断结果为 false 时的取值 </p>
<p>6) 正则表达式：matches </p>
]]></content>
  </entry>
  <entry>
    <title>Mysql数据库（基础）</title>
    <url>/2019/10/25/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
    <content><![CDATA[<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><p>1、DB：数据库，保存一组有组织的数据的容器。<br>​2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据，常见的DBMS为MySql,Oracle,SqlServer,DB2。。。<br>​3、SQL:结构化查询语言，用于和DBMS通信的语言。</p>
<h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>​    方式一：计算机——右击管理——服务<br>​    方式二：通过管理员身份运行<br>​    net start 服务名（启动服务）<br>​    net stop 服务名（停止服务）</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：通过mysql自带的客户端</span><br><span class="line">只限于root用户</span><br><span class="line"></span><br><span class="line">方式二：通过windows自带的客户端</span><br><span class="line">登录：</span><br><span class="line">mysql 【-h主机名 -P端口号 】-u用户名 -p密码</span><br><span class="line">例如： mysql -u root -p123456</span><br><span class="line">退出：</span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure>



<h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名;</span><br><span class="line"></span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line"></span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line">	列名 列类型，</span><br><span class="line">	...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br></pre></td></tr></table></figure>





<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><p>​    1.不区分大小写,但建议关键字大写，表名、列名小写。<br>​    2.每条命令最好用分号结尾。<br>​    3.每条命令根据需要，可以进行缩进或换行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字    -- 注释文字 (注意中间要带有一个空格才能生效)</span><br><span class="line">多行注释：/* 注释文字 */</span><br></pre></td></tr></table></figure>



<h2 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h2><p><strong>1.DQL（Data Query Language)：数据查询语言</strong><br>        select<br><strong>2.DML  (Data Manipulate Language):   数据操作语言</strong><br>        insert 、update、delete<br><strong>3.DDL（Data Define Languge)：数据定义语言</strong><br>        create、drop、alter<br><strong>4.TCL （Transaction Control Language)：事务控制语言</strong><br>        commit、rollback、savepoint</p>
<p><strong>5.DCL（Data Control Language)：数据控制语言</strong></p>
<p>   　 grant、revoke</p>
<hr>
<h3 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h3><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">查询表的所有数据:  SELECT * FROM 表名;  </span><br><span class="line">查询表中指定字段的值: SELECT 字段1,字段2...字段n FROM 表名;</span><br></pre></td></tr></table></figure>

<p>特点：<br>①通过select查询完的结果 ,是一个虚拟的表格，不是真实存在。<br>②要查询的东西可以是常量值、可以是表达式、可以是字段、可以是函数。</p>
<p>4</p>
<h5 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#给查询结果中的字段使用别名</span><br><span class="line">字段名 as 别名</span><br><span class="line">或者</span><br><span class="line">字段名 &quot;别名&quot;</span><br><span class="line">SELECT name as &quot;花名&quot; FROM  flower;</span><br></pre></td></tr></table></figure>

<p>注意: as可以省略不写，别名中没有特殊字符，双引号也可以省略不写。</p>
<h5 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 字段1,字段2...字段n  FROM 表名;</span><br></pre></td></tr></table></figure>

<p>注意：去除重复的规则是按照行进行去除的,多行数据完全相同取其一,DISTINCT必须放在要查询字段的开头。</p>
<h5 id="号"><a href="#号" class="headerlink" title="+号"></a>+号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#仅仅只有一个功能:运算符</span><br><span class="line"></span><br><span class="line">#两个操作数为数值型，则做加法运算</span><br><span class="line">SELECT 100+90;  -- 190</span><br><span class="line"></span><br><span class="line">#只要其中一方为字符型，试图将字符型数值转换成数值型 </span><br><span class="line">#1.如果转换成功,则继续做加法运算</span><br><span class="line">#2.如果转换失败,则将字符型数值转换为0</span><br><span class="line">SELECT &quot;100&quot;+90; -- 190</span><br><span class="line">SELECT &quot;Tom&quot;+90; -- 90</span><br><span class="line"></span><br><span class="line">#只要其中一方为null,则结果肯定为null</span><br><span class="line">SELECT null+90; -- null</span><br></pre></td></tr></table></figure>



<h5 id="concat实现拼接操作"><a href="#concat实现拼接操作" class="headerlink" title="concat实现拼接操作"></a>concat实现拼接操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用方法 </span><br><span class="line">CONCAT(str1,str2...)  </span><br><span class="line"></span><br><span class="line">SELECT CONCAT(1,3,4);  测试  -- 一个数字参数被转化为与之相等的二进制字符串格式</span><br><span class="line">SELECT CONCAT(id,&apos;,&apos;,name) &quot;编号,花名&quot; from flower;</span><br></pre></td></tr></table></figure>

<p>注意:返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。</p>
<hr>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>条件查询：根据条件过滤原始表的数据，查询到想要的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 要查询的字段|表达式|常量值|函数 from 表名 where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="一、条件表达式"><a href="#一、条件表达式" class="headerlink" title="一、条件表达式"></a>一、条件表达式</h5><p>条件运算符：&gt;   &lt;   &gt;=   &lt;=   =   &lt;&gt;   !=</p>
<h5 id="二、逻辑表达式"><a href="#二、逻辑表达式" class="headerlink" title="二、逻辑表达式"></a>二、逻辑表达式</h5><p>逻辑运算符：<br>    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false。<br>    or (||)：两个条件只要有一个成立，结果为true，否则为false。<br>    not  (!)：如果条件成立，则not后为false，否则为true。</p>
<p>​    </p>
<h5 id="三、模糊查询"><a href="#三、模糊查询" class="headerlink" title="三、模糊查询"></a>三、模糊查询</h5><p>   %： 代替0个或多个任意字符。<br>    _ ：代替1个任意字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * From flower where name like &apos;_a%&apos;;</span><br><span class="line">#转义关键词  ESCAPE</span><br><span class="line">SELECT * From flower where name like &apos;_\_%&apos;;</span><br><span class="line">SELECT * From flower where name like &apos;_$_%&apos; ESCAPE &apos;$&apos;;</span><br></pre></td></tr></table></figure>



<h5 id="四、关键字-between-and"><a href="#四、关键字-between-and" class="headerlink" title="四、关键字  between  and"></a>四、关键字  between  and</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#包含两头的数据 [ , ]</span><br><span class="line">SELECT * From emp where sal &gt;=200 and sal&lt;=300;</span><br><span class="line">#等价与</span><br><span class="line">SELECT * From emp where sal between 200 and 300;</span><br></pre></td></tr></table></figure>



<h5 id="五、关键字-in"><a href="#五、关键字-in" class="headerlink" title="五、关键字 in"></a>五、关键字 in</h5><p>含义:判断某字段的值是否属于in列表中的某一项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#格式</span><br><span class="line">in (目标值1，目标值2，...) -- in 中的内容只能为一个字段的值,目标值之间必须使用逗号分隔,并且括在括号中。</span><br><span class="line">SELECT * From emp where job in (&apos;Salesman&apos;,&apos;manager&apos;,&apos;analyst&apos;);</span><br></pre></td></tr></table></figure>



<h5 id="六、关键字-is-null-is-not-null"><a href="#六、关键字-is-null-is-not-null" class="headerlink" title="六、关键字  is null  , is not null"></a>六、关键字  is null  , is not null</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#格式 </span><br><span class="line">SELECT * FROM 表名 WHERE 字段名 is null; -- 字段值为Null</span><br><span class="line">SELECT * FROM 表名 WHERE 字段名 is not null; -- 字段值不为Null</span><br><span class="line">SELECT * FROM emp WHERE comm is not null; -- 字段值不为Null</span><br></pre></td></tr></table></figure>

<p>注意: 不能使用=,&lt;&gt;来判断NULL值。</p>
<h5 id="七、安全等于-lt-gt"><a href="#七、安全等于-lt-gt" class="headerlink" title="七、安全等于 &lt;=&gt;"></a>七、安全等于 &lt;=&gt;</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM flower WHERE production &lt;=&gt; null;</span><br></pre></td></tr></table></figure>

<p>is null : 仅仅可以判断NULL值，可读性高,建议使用。</p>
<p>&lt;=&gt; :  既可以判断NULL值,又可以判断普通数值，可读性较低。</p>
<hr>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">#单字段排序</span><br><span class="line">select 要查询的东西 from 表名 where 筛选条件 order by 排序的字段|表达式|函数|别名 [asc|desc]</span><br><span class="line"></span><br><span class="line">#多字段排序</span><br><span class="line">select 要查询的东西 from 表名 where 筛选条件 order by 字段名1 [asc|desc],字段名2 [asc|desc]...</span><br></pre></td></tr></table></figure>

<p>注意: </p>
<p>1.asc代表的是升序,desc代表的是降序,如果不写,默认为升序。</p>
<p>2.order by 子句中可以支持单个字段,多个字段,表达式,函数,别名。</p>
<p>3.order by 子句一般是放在查询语句的最后面,limit子句除外。</p>
<hr>
<h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><h5 id="一、单行函数"><a href="#一、单行函数" class="headerlink" title="一、单行函数"></a>一、单行函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用法</span><br><span class="line">SELECT 函数名() FROM 表名 WHERE 筛选条件</span><br><span class="line">1、字符函数</span><br><span class="line">	concat　拼接</span><br><span class="line">	substr　截取子串  -- 注意：索引从1开始</span><br><span class="line">	upper　转换成大写</span><br><span class="line">	lower　转换成小写</span><br><span class="line">	trim　去前后指定的空格和字符</span><br><span class="line">	ltrim　去左边空格</span><br><span class="line">	rtrim　去右边空格</span><br><span class="line">	replace　替换</span><br><span class="line">	lpad　用指定的字符实现左填充指定长度</span><br><span class="line">	rpad　用指定的字符实现右填充指定长度</span><br><span class="line">	instr　返回子串第一次出现的索引 -- 如果找不到返回0</span><br><span class="line">	length 获取字节个数</span><br><span class="line"></span><br><span class="line">2、数学函数</span><br><span class="line">	round 四舍五入</span><br><span class="line">	rand 随机数</span><br><span class="line">	floor 向下取整 -- &lt;=该参数的最大整数</span><br><span class="line">	ceil 向上取整  -- &gt;=该参数的最小整数</span><br><span class="line">	mod 取余</span><br><span class="line">	truncate 截断</span><br><span class="line">	</span><br><span class="line">3、日期函数</span><br><span class="line">	now 当前系统日期+时间</span><br><span class="line">	curdate 当前系统日期</span><br><span class="line">	curtime 当前系统时间</span><br><span class="line">	str_to_date 将字符转换成日期</span><br><span class="line">	date_format  将日期转换成字符</span><br><span class="line">	DATEDIFF 求两个日期相差的天数 </span><br><span class="line">	SELECT DATEDIFF(now(),&quot;1998-05-27&quot;) </span><br><span class="line">	</span><br><span class="line">4、流程控制函数</span><br><span class="line">	#if 处理双分支 -- if else的效果</span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct is null,&apos;没奖金,呵呵&apos;,&apos;有奖金,嘻嘻&apos;) 备注 FROM employees;</span><br><span class="line"></span><br><span class="line">	#case语句 </span><br><span class="line">	#1.类似 switch-case的效果</span><br><span class="line">	case 要判断的字段或表达式</span><br><span class="line">    when 常量1 then 要显示的值1或者语句1;</span><br><span class="line">    when 常量2 then 要显示的值2或者语句2;</span><br><span class="line">    ...</span><br><span class="line">    else 要显示的值n或者语句n;</span><br><span class="line">    end</span><br><span class="line">    #例子</span><br><span class="line">	SELECT salary 原始工资,department_id,</span><br><span class="line">    CASE department_id</span><br><span class="line">      WHEN 30 THEN salary*1.1</span><br><span class="line">      WHEN 40 THEN salary*1.2</span><br><span class="line">      WHEN 50 THEN salary*1.3</span><br><span class="line">      ELSE salary</span><br><span class="line">    END AS 新工资  FROM employees</span><br><span class="line">    </span><br><span class="line">    #2.类似 多重if</span><br><span class="line">    case </span><br><span class="line">    when 条件1 then 要显示的值1或者语句1;</span><br><span class="line">    when 条件2 then 要显示的值2或者语句2;</span><br><span class="line">    ...</span><br><span class="line">    else 要显示的值n或者语句n;</span><br><span class="line">    end</span><br><span class="line">    #例子</span><br><span class="line">    SELECT salary ,</span><br><span class="line">    CASE </span><br><span class="line">     WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">     WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">     WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">     ELSE &apos;D&apos;</span><br><span class="line">    END AS 工资级别 FROM employees</span><br><span class="line">    </span><br><span class="line">5、其他函数</span><br><span class="line">	version 版本</span><br><span class="line">	database 当前库</span><br><span class="line">	user 当前连接用户</span><br><span class="line">	md5(&apos;字符&apos;) 返回该字符的md5加密形式 </span><br><span class="line">	datediff(大的日期，小的日期) 返回两个日期的时间差</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h5 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计算个数</span><br></pre></td></tr></table></figure>

<p>特点：<br><em>1、*sum,max,min,avg,count(字段名)都忽略null值，count(</em> )不忽略null值。<br>2、sum和 avg一般用于处理数值型；max、min、count可以处理任何数据类型。<br>3、都可以搭配distinct使用，用于统计去重后的结果。<br>4、count的参数可以支持：字段、常量值、* ，一般放1,建议使用 count(*)。</p>
<p>效率：</p>
<p>MyISAM存储引擎下,count(*)的效率高。</p>
<p>InnoDB存储引擎下,count(*)和count(1)的效率差不多，比count(字段名)要高一些。</p>
<hr>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">#分组前的筛选</span><br><span class="line">select 查询的字段，分组函数</span><br><span class="line">from 表名</span><br><span class="line">[where 筛选条件]</span><br><span class="line">group by 分组的字段</span><br><span class="line">[order by 子句]</span><br><span class="line"></span><br><span class="line">#分组后的筛选 having 子句</span><br><span class="line">-- 查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line">select MAX(salary),job_id from employees where commission_pct is not null</span><br><span class="line">group by job_id having MAX(salart)&gt;12000;</span><br><span class="line"></span><br><span class="line">-- 按员工姓名的长度分组,查询每一组的员工个数，筛选员工个数&gt;5</span><br><span class="line">select count(*) c,LENGTH(last_name) len_name from employees </span><br><span class="line">group by len_name having c&gt;5;</span><br><span class="line">#group by,having后可以支持别名。</span><br></pre></td></tr></table></figure>

<p>特点：<br>1、支持按单个字段分组;也可以按多个字段分组,多个字段之间用逗号隔开,没有顺序要求;表达式或函数(用得较少)。<br>2、和分组函数一同查询的字段最好是分组后的字段。<br>3、分组筛选<br>针对的表             位置            关键字<br>分组前筛选：    原始表        group by的前面        where<br>分组后筛选：    分组后的结果集    group by的后面        having</p>
<p>分组函数做条件肯定是放在having子句中。</p>
<p>4.查询列表必须特殊,要求是分组函数和group by后出现的字段。</p>
<hr>
<h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><h5 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a><strong>一、分类</strong></h5><p>按年代分类：</p>
<p>sql92标准，sql99标准</p>
<p>按功能分类:</p>
<p>内连接：等值连接,非等值连接,自连接</p>
<p>外连接：左外连接,右外连接,全外连接</p>
<p>交叉连接</p>
<h5 id="二、笛卡尔乘积"><a href="#二、笛卡尔乘积" class="headerlink" title="二、笛卡尔乘积"></a><strong>二、笛卡尔乘积</strong></h5><p>表1有m行，表2有n行,结果为m*n行。<br>解决办法：添加上有效的连接条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp,dept;</span><br></pre></td></tr></table></figure>



<h5 id="三、sql92标准"><a href="#三、sql92标准" class="headerlink" title="三、sql92标准"></a><strong>三、sql92标准</strong></h5><p>含义：1992年推出的sql语法。</p>
<p>仅仅支持内连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.等值连接 先做笛卡尔积，然后筛选,筛选条件为等值筛选。</span><br><span class="line">select e.ename,e.job,d.dname from emp e,dept d where e.deptno = d.deptno;</span><br><span class="line">/*</span><br><span class="line">1.多表等值连接的结果为多表的交集部分。</span><br><span class="line">2.n表连接，至少需要n-1个连接条件。</span><br><span class="line">3.多表的顺序没有要求，一般需要为表起别名。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#2.非等值连接</span><br><span class="line">select * from emp e,sqlgrade s where e.sal&gt;=s.losal and e.sal&lt;=s.hisal;</span><br><span class="line"></span><br><span class="line">#3.自连接</span><br><span class="line">-- 查询员工姓名,工作,薪资,及上级领导的姓名</span><br><span class="line">select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr=e2.empno;</span><br></pre></td></tr></table></figure>



<h5 id="四、sql99标准-推荐使用"><a href="#四、sql99标准-推荐使用" class="headerlink" title="四、sql99标准[推荐使用]"></a>四、sql99标准[推荐使用]</h5><p>含义：1999年推出的sql语法。<br>支持：内连接,外连接(左外连接，右外连接),交叉连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">【inner|left [outer]|right [outer]|cross】join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选条件】</span><br><span class="line">【order by 排序的字段或表达式】</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 内连接</span><br><span class="line">#1.等值连接</span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">[inner] join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">[where 筛选条件]</span><br><span class="line"></span><br><span class="line">select e.ename,e.job,d.dname </span><br><span class="line">from emp e</span><br><span class="line">inner join dept d </span><br><span class="line">on e.deptno = d.deptno</span><br><span class="line">where e.deptno=1001;</span><br><span class="line">/*</span><br><span class="line">1.inner可以省略。</span><br><span class="line">2.连接条件放在on后面,筛选条件放在where后面,提高分离性,便于阅读。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#2.非等值连接</span><br><span class="line">select * </span><br><span class="line">from emp e</span><br><span class="line">inner join sqlgrade s </span><br><span class="line">on e.sal&gt;=s.losal and e.sal&lt;=s.hisal;</span><br><span class="line"></span><br><span class="line">#3.自连接</span><br><span class="line">select e1.ename,e1.job,e1.sal,e2.ename </span><br><span class="line">from emp e1</span><br><span class="line">inner join emp e2 </span><br><span class="line">on e1.mgr=e2.empno;</span><br><span class="line"></span><br><span class="line">-- 外连接</span><br><span class="line">#应用场景:用于查询一个表中有，另一个表没有的记录。</span><br><span class="line">/*</span><br><span class="line">特点：</span><br><span class="line">1.外连接的查询结果为主表中的所有记录</span><br><span class="line">  如果从表中有和它匹配的,则显示匹配的值。</span><br><span class="line">  如果从表中没有和它匹配的,则显示null。</span><br><span class="line">  外连接查询的结果=内连接+主表中有而从表没有的记录。</span><br><span class="line">2.左外连接：left join左边的是主表</span><br><span class="line">  右外连接：left join右边的是主表</span><br><span class="line">3.左外和右外交换两个表的顺序,可以实现同样的效果。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#1.左外连接与右外连接</span><br><span class="line">-- 左外连接</span><br><span class="line">select e.*,d.* </span><br><span class="line">from emp e</span><br><span class="line">left outer join dept d</span><br><span class="line">on e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">-- 右外连接</span><br><span class="line">select e.*,d.* </span><br><span class="line">from emp e</span><br><span class="line">right outer join dept d</span><br><span class="line">on e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">#2.交叉连接 本质就是笛卡尔积</span><br><span class="line">select e.*,d.* from emp e</span><br><span class="line">cross join dept d</span><br><span class="line">on e.deptno=d.deptno;</span><br></pre></td></tr></table></figure>



<p><strong>五、sql92 与 sql99的比较</strong></p>
<p>功能：sql99支持的较多。</p>
<p>可读性：sql99实现连接条件和筛选条件的分离,可读性较高。</p>
<p>推荐性: 建议使用sql99。</p>
<hr>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：</p>
<p>​    一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询;在外面的查询语句，称为主查询或外查询。</p>
<p>分类：</p>
<p>按子查询出现的位置：     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 后面：</span><br><span class="line">	仅仅支持标量子查询</span><br><span class="line">from 后面:</span><br><span class="line">	支持表子查询</span><br><span class="line">where或having后面:</span><br><span class="line">	标量子查询 (单行子查询)</span><br><span class="line">	列子查询   (多行子查询)</span><br><span class="line">	行子查询   (多列多行)</span><br><span class="line">exists 后面 (相关子查询)</span><br><span class="line">       表子查询</span><br></pre></td></tr></table></figure>

<p>按结构集的行列数不同:<br>           标量子查询（结果集只有一行一列）</p>
<p>​           列子查询    （结果集只有一列多行）</p>
<p>​           行子查询    （结果集有一行多列）    </p>
<p>​           表子查询      (结果集一般为多行多列）    </p>
<p>特点：</p>
<p>1、子查询都放在小括号内<br>2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧<br>3、子查询优先于主查询执行，主查询使用了子查询的执行结果<br>4、子查询根据查询结果的行数不同分为以下两类：<br>① 单行子查询<br>    结果集只有一行<br>    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=<br>    非法使用子查询的情况：<br>    a、子查询的结果为一组值<br>    b、子查询的结果为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 标量子查询</span><br><span class="line">-- 查询工资比Tom高的员工信息</span><br><span class="line">select *</span><br><span class="line">form emp</span><br><span class="line">where sal&gt;(</span><br><span class="line">			select sal</span><br><span class="line">    		from emp </span><br><span class="line">    		where ename = &apos;Tom&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询最低工资大于50号的最低工资的部门编号和其最低工资。</span><br><span class="line">select min(sal),deptno</span><br><span class="line">from emp </span><br><span class="line">group by deptno</span><br><span class="line">having min(sal)&gt;(</span><br><span class="line">    			select min(sal) </span><br><span class="line"> 				from emp </span><br><span class="line">				where deptno=50</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>② 多行子查询<br>    结果只有一个字段但是字段有n个值。</p>
<p>​    一般搭配多行操作符使用：any、all、in、not in。</p>
<p>​    any:    任意</p>
<p>​    all:    所有</p>
<p>​    in：表示任意存在，相当于=any。</p>
<p>​    not in :相当于&lt;&gt; all。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关键字 any</span><br><span class="line">-- 查询工资高于任意一个CLERK的所有员工信息。</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where sal &gt; any(</span><br><span class="line">				select sal</span><br><span class="line">    			from emp </span><br><span class="line">    			where job=&apos;CLERK&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#关键词 all</span><br><span class="line">-- 查询工资高于所有SALESMAN的员工信息。</span><br><span class="line">select * </span><br><span class="line">from emp </span><br><span class="line">where sal &gt; all(</span><br><span class="line">				select sal</span><br><span class="line">    			from emp </span><br><span class="line">    			where job=&apos;SALESMAN&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#关键词 in</span><br><span class="line">-- 查询部门号20中同部门10的雇员工作一样的雇员信息。</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where job in (</span><br><span class="line">			 select job</span><br><span class="line">    		 from emp </span><br><span class="line">    		 where deptno=10</span><br><span class="line">) and deptno =20;</span><br><span class="line">-- 等价于</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where job = any(</span><br><span class="line">			 select job</span><br><span class="line">    		 from emp </span><br><span class="line">    		 where deptno=10</span><br><span class="line">) and deptno =20;</span><br></pre></td></tr></table></figure>

<p>行子查询 (使用频率少)</p>
<p>​    结果集一行多列或者多行多列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工编号最小并且工资最高的员工信息。</span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where empno = (</span><br><span class="line">				select min(empno)</span><br><span class="line">    			from emp</span><br><span class="line">)  and sal = (</span><br><span class="line">    			select max(sal)</span><br><span class="line">    			from emp</span><br><span class="line">);</span><br><span class="line">-- 等价于</span><br><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where (empno,sal) = (</span><br><span class="line">					select min(empno),max(sal)</span><br><span class="line">    				from emp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>from后面的子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询每个部门的平均工资的工资等级</span><br><span class="line">-- 将子查询结果充当一张表,要求必须起别名</span><br><span class="line">select avg_dep.*,s.grade</span><br><span class="line">from (</span><br><span class="line">	 select avg(sal) avg,deptno</span><br><span class="line">     from emp </span><br><span class="line">     group by deptno</span><br><span class="line">) avg_dep</span><br><span class="line">inner join salgrade s</span><br><span class="line">on avg_dep.avg between losal and hisal;</span><br></pre></td></tr></table></figure>

<p>exists后面的子查询 （相关子查询）</p>
<p>EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值true或false,结果为1或0。</p>
<p>语法: exists (完整的查询语句)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询有员工的部门名</span><br><span class="line">select d.dname </span><br><span class="line">from dept d</span><br><span class="line">where exists (</span><br><span class="line">			select *</span><br><span class="line">    		from emp e</span><br><span class="line">     		where d.deptno =e.deptno   		</span><br><span class="line">);</span><br><span class="line">-- 等价于</span><br><span class="line">select d.dname </span><br><span class="line">from dept d</span><br><span class="line">where d.deptno in (</span><br><span class="line">			select deptno</span><br><span class="line">    		from emp     				</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>应用场景：</p>
<p>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|表达式,...</span><br><span class="line">from 表</span><br><span class="line">【where 条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 条件】</span><br><span class="line">【order by 排序的字段】</span><br><span class="line">limit 【起始的条目索引，】条目数;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1.起始条目索引从0开始。</p>
<p>2.limit子句放在查询语句的最后</p>
<p>3.公式：select * from  表 limit （page-1）*size,size<br>每页显示条目数size<br>要显示的页数 page</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询前五条员工的信息</span><br><span class="line">select * from emp limit 0,5;</span><br><span class="line">select * from emp limit 5;</span><br><span class="line"></span><br><span class="line">#查询第11条-第25条</span><br><span class="line">select * from emp 10,15;</span><br><span class="line"></span><br><span class="line">#有奖金的员工信息,并且工资较高的前10名显示出来</span><br><span class="line">select * </span><br><span class="line">from emp</span><br><span class="line">where comm is not null</span><br><span class="line">order by sal desc</span><br><span class="line">limit 0,10;</span><br></pre></td></tr></table></figure>



<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>引入：<br>    union 联合、合并：将多条查询语句的结果合并成一个结果。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】</span><br><span class="line">.....</span><br><span class="line">select 字段|常量|表达式|函数 【from 表】 【where 条件】</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1、多条查询语句的查询的列数必须是一致的。<br>2、多条查询语句的查询的列的类型几乎相同。<br>3、union代表去重，union all代表不去重。</p>
<p>应用场景：</p>
<p>要查询的结果来自于多个表，且多个表没有直接的连接关系,但查询的信息一致时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询中国用户中男性的信息以及外国用户中年男性的用户信息</span><br><span class="line">select id,cname,csex from t_ca where csex =&apos;男&apos;</span><br><span class="line">union</span><br><span class="line">select t_id,tname from t_ua where tGender=&apos;male&apos;;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DML语言的学习"><a href="#DML语言的学习" class="headerlink" title="DML语言的学习"></a>DML语言的学习</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">-- 方式一 支持插入多行，支持子查询</span><br><span class="line">	insert into 表名(字段名，...) values(值1，...);</span><br><span class="line">-- 方式二 </span><br><span class="line">	insert into 表名 set 列名1=值1,列名2=值2...;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1、字段类型和值类型一致或兼容，而且一一对应。<br>2、可以为空的字段，可以不用插入值，或用null填充。<br>3、不可以为空的字段，必须插入值。<br>4、字段个数和值的个数必须一致。<br>5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一支持插入多行</span><br><span class="line">insert into beauty</span><br><span class="line">values(1603,&apos;尹远洋&apos;,&apos;男&apos;,23),(1604,&apos;张三&apos;,&apos;男&apos;,21),(1605,&apos;李丽&apos;,&apos;女&apos;,18);</span><br><span class="line"></span><br><span class="line">#支持子查询</span><br><span class="line">insert into beauty(id,name,age) select 1603,&apos;尹远洋&apos;,23;</span><br></pre></td></tr></table></figure>



<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>修改单表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段=新值,字段=新值 where 筛选条件;</span><br></pre></td></tr></table></figure>

<p>修改多表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sql92语法</span><br><span class="line">update 表1 别名1,表2 别名2</span><br><span class="line">set 字段=新值，字段=新值</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">#sql99语法</span><br><span class="line">update 表1 别名1</span><br><span class="line">inner|left|right join 表2 别名2</span><br><span class="line">on 连接条件</span><br><span class="line">set 字段=新值，字段=新值</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="方式1：delete语句"><a href="#方式1：delete语句" class="headerlink" title="方式1：delete语句"></a>方式1：delete语句</h5><p>单表的删除： ★</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 [where 筛选条件];</span><br></pre></td></tr></table></figure>

<p>多表的删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#sql92语法</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br><span class="line">	</span><br><span class="line">#sql99语法</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1</span><br><span class="line">	inner|left|right join 表2 别名2</span><br><span class="line">	on 连接条件</span><br><span class="line">	where 筛选条件;</span><br></pre></td></tr></table></figure>

<h5 id="方式2：truncate语句"><a href="#方式2：truncate语句" class="headerlink" title="方式2：truncate语句"></a>方式2：truncate语句</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<p>两种方式的区别【面试题】</p>
<p>1.truncate不能加where条件，而delete可以加where条件。</p>
<p>2.truncate的效率高一丢丢。</p>
<p>3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始；<br>delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。</p>
<p>4.truncate删除没有返回值，delete删除有返回值。</p>
<p>4.truncate删除不能回滚，delete删除可以回滚。</p>
<hr>
<h3 id="DDL语言的学习"><a href="#DDL语言的学习" class="headerlink" title="DDL语言的学习"></a>DDL语言的学习</h3><h4 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h4><h5 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建库</span><br><span class="line">create database [if not exists] 库名;</span><br><span class="line">#修改库 </span><br><span class="line">-- 目前不能用了,不安全</span><br><span class="line">#更改库的字符集</span><br><span class="line">alter database 库名 character set 字符集;</span><br><span class="line">#删除库</span><br><span class="line">drop database [if exists] 库名;</span><br></pre></td></tr></table></figure>



<h5 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建表</span><br><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">	列名 列的类型[(长度) 约束],</span><br><span class="line">    列名 列的类型[(长度) 约束],</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	stuId INT,</span><br><span class="line">	stuName VARCHAR(20),</span><br><span class="line">	gender CHAR,</span><br><span class="line">	bornDate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改表 alter</span><br><span class="line">语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br><span class="line"></span><br><span class="line">#①修改字段名</span><br><span class="line">ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;</span><br><span class="line"></span><br><span class="line">#②修改表名</span><br><span class="line">ALTER TABLE stuinfo RENAME [TO] studentinfo;</span><br><span class="line"></span><br><span class="line">#③修改字段类型和列级约束</span><br><span class="line">ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;</span><br><span class="line"></span><br><span class="line">#④添加字段</span><br><span class="line">ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20);</span><br><span class="line"></span><br><span class="line">#⑤删除字段</span><br><span class="line">ALTER TABLE studentinfo DROP COLUMN email;</span><br><span class="line"></span><br><span class="line">#删除表</span><br><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br><span class="line"></span><br><span class="line">#表的复制</span><br><span class="line">-- 1.仅仅复制表的结构</span><br><span class="line">create table 表名 like 表名;</span><br><span class="line"></span><br><span class="line">-- 2.复制表的结构+数据</span><br><span class="line">create table 新表 select * from 旧表;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h4><p>整型：<br>    tinyint、smallint、mediumint、int/Integer、bigint<br>小数：<br>    浮点型: float、double<br>    定点型:dec(M,D)、decimal(M,D)</p>
<p>​    特点：</p>
<p>​    1.M：整数部位+小数部位</p>
<p>​    D:小数部位</p>
<p>​    如果超过范围，则插入临界值。</p>
<p>​    2.M和D都可以省略，如果是decimal，则M默认为10,D默认为0。</p>
<p>​    如果是float和double,则会根据插入的数值的精度来决定精度。</p>
<p>​    3.定点型的精确度较高,如果要求插入数值的精度较高如货币运算等则考虑使用。</p>
<p>字符型：</p>
<p>较短的文本:char 、varchar</p>
<p>较长的文本:text、blob(较大的二进制)</p>
<table>
<thead>
<tr>
<th></th>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>char(M)</td>
<td>最大的字符数,可以省略,默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar</td>
<td>varchar(M)</td>
<td>最大的字符数,不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody></table>
<p>其他：</p>
<p>binary和varbinary用于保存较短的二进制。</p>
<p>enum用于保存枚举。</p>
<p>set用于保存集合。</p>
<p>日期型：</p>
<p>分类：</p>
<p>​    data:只保存日期</p>
<p>​    time:只保存时间</p>
<p>​    year:只保存年</p>
<p>​    datetime:保存日期+时间</p>
<p>​    timestamp:保存日期+时间</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区等的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<p>Blob类型：</p>
<p>​        ·tinyblob:仅255个字符<br>　　·blob:最大限制到65K字节<br>　　·mediumblob:限制到16M字节<br>　　·longblob:可达4GB</p>
<h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOT NULL:非空,用来保证该字段的值不能为空</span><br><span class="line">DEFAULT:默认,用于保证该字段有默认值</span><br><span class="line">UNIQUE:唯一,用于保证该字段的值具有唯一性,可以为空</span><br><span class="line">CHECK:检查约束  [mysql中不支持]</span><br><span class="line">PRIMARY KEY:主键,用于保证该字段的值具有唯一性,并且非空</span><br><span class="line">FOREIGN KEY:外键,用于限制两个表的关系,用于保证该字段的值必须来自于主表的关联列的值</span><br><span class="line">在从表添加外键约束,用于引用主表中某列的值</span><br></pre></td></tr></table></figure>

<p>添加约束的时机：</p>
<p>​        1.创建表时</p>
<p>​        2.修改表时</p>
<p>约束的添加分类：</p>
<p>​            列级约束：</p>
<p>​                        六大约束语法上都支持,但是外键约束没有效果</p>
<p>​            表级约束：</p>
<p>​                        除了非空,默认,其他的都支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段名 字段类型 列级约束,</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	表级约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>列级约束</p>
<p>语法：直接在字段名和类型后面追加约束类型即可。</p>
<p>只支持:默认,非空,主键,唯一。</p>
<p>表级约束</p>
<p>支持：主键,外键,唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[constraint 约束名] 约束类型(字段名);</span><br><span class="line">constraint pk PRIMARY KEY(id), #主键约束</span><br><span class="line">UNIQUE(seat), #唯一键</span><br><span class="line">constraint fk_stuinfo_major FOREIGN KEY(majorid) references major(id)  #外键约束</span><br></pre></td></tr></table></figure>



<p>主键和唯一的区别:</p>
<table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可以有多少个</th>
<th>是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>√</td>
<td>×</td>
<td>至多有一个</td>
<td>√，但不推荐</td>
</tr>
<tr>
<td>唯一</td>
<td>√</td>
<td>√</td>
<td>可以有多个</td>
<td>√，但不推荐</td>
</tr>
</tbody></table>
<p>外键：</p>
<p>1.要求在从表设置外键关系。</p>
<p>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称没要求。</p>
<p>3.主表的关联列必须是一个key（一般是主键或者唯一)。</p>
<p>4.插入数据时,先插入主表,再插入从表。<br>删除数据时,先删除从表,再删除主表。</p>
<p>修改表时添加约束</p>
<p>1.添加列级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br></pre></td></tr></table></figure>

<p>2.添加表级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用];</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加非空约束</span><br><span class="line">alter table stuinfo modify column stuname varchar(20) not null;</span><br><span class="line">#添加默认约束</span><br><span class="line">alter table stuinfo modify column age int  default 18;</span><br><span class="line">#添加主键</span><br><span class="line">-- 列级约束</span><br><span class="line">alter table stuinfo modify column id  int primary key;</span><br><span class="line">-- 表级约束</span><br><span class="line">alter table stuinfo add primary key(id);</span><br><span class="line">#添加唯一</span><br><span class="line">-- 列级约束</span><br><span class="line">alter table stuinfo modify column seat int unique;</span><br><span class="line">-- 表级约束</span><br><span class="line">alter table stuinfo add unique(seat);</span><br><span class="line">#添加外键</span><br><span class="line">-- 表级约束</span><br><span class="line">alter table stuinfo add constraint fk_stuinfo_major foreign key(majorid) references major(id);</span><br></pre></td></tr></table></figure>



<p>修改表时删除约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除非空约束</span><br><span class="line">alter table stuinfo modify column stuname varchar(20)  null;</span><br><span class="line">#删除默认约束</span><br><span class="line">alter table stuinfo modify column age int ;</span><br><span class="line">#删除主键</span><br><span class="line">alter table stuinfo drop primary key;</span><br><span class="line">#删除唯一</span><br><span class="line">alter table stuinfo drop index seat;</span><br><span class="line">#删除外键</span><br><span class="line">alter table stuinfo drop foreign key fk_stuinfo_major;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列的下面</td>
<td>默认和非空不支持,其他支持</td>
<td>可以(主键没有效果)</td>
</tr>
</tbody></table>
<p>标识列</p>
<p>又称为自增长列。含义：可以不用手动的插入值，系统提供默认的序列值。</p>
<p>特点:</p>
<p>1.标识列要求是一个key。</p>
<p>2.一个表至多一个标识列。</p>
<p>3.标识列的类型只能是数值型。</p>
<p>4.标识列可以通过set auto_increment_increment=数字；设置步长</p>
<p>可以通过手动插入值 ,设置起始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>修改表时设置标识列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user modify column id int primary key auto_increment;</span><br></pre></td></tr></table></figure>

<p>删除表时设置标识列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user modify column id int;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><h4 id="特点-ACID"><a href="#特点-ACID" class="headerlink" title="特点(ACID):"></a>特点(ACID):</h4><p>​    原子性（Atomicity）：一个事务不可再分割,要么都执行要么都不执行。<br>​    一致性(Consistency)：一个事务保证数据的状态操作前和操作后保持一致。<br>​    隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。<br>​    持久性(Durability)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。</p>
<h4 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h4><p>隐式事务，没有明显的开启和结束事务的标志。</p>
<p>比如insert、update、delete语句本身就是一个事务。</p>
<p>显式事务，具有明显的开启和结束事务的标志。</p>
<p>前提：必须先设置自动提交功能为禁用。</p>
<p>set autocommit=0;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#步骤1:开启事务</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction; #可选的</span><br><span class="line">	</span><br><span class="line">#步骤2.编写事务的一组逻辑操作单元（多条sql语句）</span><br><span class="line">	select</span><br><span class="line">	insert</span><br><span class="line">	update</span><br><span class="line">	delete	</span><br><span class="line">	</span><br><span class="line">#步骤3.提交事务或回滚事务</span><br><span class="line">	commit; 提交事务</span><br><span class="line">	rollback; 回滚事务</span><br></pre></td></tr></table></figure>

<h4 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line">start transaction;</span><br><span class="line">commit;</span><br><span class="line">rollback;</span><br><span class="line">savepoint  断点</span><br><span class="line">commit to 断点</span><br><span class="line">rollback to 断点</span><br><span class="line"></span><br><span class="line">#演示savepoint的使用</span><br><span class="line">set autocommit=0;</span><br><span class="line">start transaction;</span><br><span class="line">delete from account where id=25;</span><br><span class="line">savepoint a;-- 设置保持点a</span><br><span class="line">delete from account where id=28;</span><br><span class="line">rollback to a; -- 回滚到保持点a</span><br></pre></td></tr></table></figure>





<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><h5 id="事务并发问题如何发生"><a href="#事务并发问题如何发生" class="headerlink" title="事务并发问题如何发生"></a>事务并发问题如何发生</h5><p>当多个事务同时操作同一个数据库的相同数据时。</p>
<h5 id="事务的并发问题有哪些"><a href="#事务的并发问题有哪些" class="headerlink" title="事务的并发问题有哪些"></a>事务的并发问题有哪些</h5><h5 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h5><p>脏读是指并发过程中，一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update account set money=money+100 where name=’B’;  (此时A通知B)</span><br><span class="line"></span><br><span class="line">update account set money=money - 100 where name=’A’;</span><br></pre></td></tr></table></figure>

<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h5 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h5><p>　　不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。</p>
<h5 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h5><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1查询<strong>整张表</strong>中有多少条记录，这时事务T2又对这个表中插入了一行数据。而操作事务T1的用户如果再查看整张表有多少行数据，会发现多出一行数据，其实这行是事务T2添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<h5 id="不可重复读和脏读的区别是"><a href="#不可重复读和脏读的区别是" class="headerlink" title="不可重复读和脏读的区别是:"></a>不可重复读和脏读的区别是:</h5><p>脏读是某一事务读取了另一个事务未提交的脏数据。</p>
<p>不可重复读则是两次读取之间存在另一个事务提交的数据。</p>
<p>　　</p>
<p><strong>幻读和不可重复读区别是：</strong></p>
<ul>
<li><p>不可重复读的重点是修改（update），操作的是某一行数据，需要锁行。同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。</p>
</li>
<li><p>幻读的重点在于新增（insert）或者删除（delete），操作的是整张表，需要锁表。同样的条件, 第1次和第2次读出来的记录数不一样。</p>
</li>
</ul>
<h5 id="如何避免事务的并发问题"><a href="#如何避免事务的并发问题" class="headerlink" title="如何避免事务的并发问题"></a>如何避免事务的并发问题</h5><p>通过设置事务的隔离级别:<br>1、READ UNCOMMITTED（读未提交）<br>2、READ COMMITTED（读已提交） 可以避免脏读<br>3、REPEATABLE READ（可重复读） 可以避免脏读、不可重复读和一部分幻读  (默认)<br>4、SERIALIZABLE  (串行化) 可以避免脏读、不可重复读和幻读</p>
<h5 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure>

<h5 id="查看隔离级别"><a href="#查看隔离级别" class="headerlink" title="查看隔离级别"></a>查看隔离级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure>



<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>含义：理解成一张虚拟的表。</p>
<p>视图和表的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>使用方式</th>
<th></th>
<th>占用物理空间</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>增删改查，一般不做增删改</td>
<td>create view</td>
<td>不占用，仅仅保存的是sql逻辑</td>
</tr>
<tr>
<td>表</td>
<td>增删改查</td>
<td>create table</td>
<td>占用</td>
</tr>
</tbody></table>
<p>视图的好处：</p>
<p>1、sql语句提高重用性，简化复杂的sql操作，效率高。<br>2、和表实现了分离，保护数据,提高了安全性。</p>
<h4 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE VIEW  视图名</span><br><span class="line">	AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>



<h5 id="视图中数据增删改查"><a href="#视图中数据增删改查" class="headerlink" title="视图中数据增删改查"></a>视图中数据增删改查</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1、查看视图的数据 ★</span><br><span class="line">SELECT * FROM my_v4;</span><br><span class="line">SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;</span><br><span class="line"></span><br><span class="line">#一般不更改视图里面的数据</span><br><span class="line">#2、插入视图的数据</span><br><span class="line">INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);</span><br><span class="line"></span><br><span class="line">#3、修改视图的数据</span><br><span class="line">UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;</span><br><span class="line"></span><br><span class="line">#4、删除视图的数据</span><br><span class="line">DELETE FROM my_v4;</span><br></pre></td></tr></table></figure>



<h5 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h5><p>​    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>​    常量视图<br>​    Select中包含子查询<br>​    join<br>​    from一个不能更新的视图<br>​    where子句的子查询引用了from子句中的表</p>
<h5 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">CREATE OR REPLACE VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT last_name FROM employees</span><br><span class="line">WHERE employee_id&gt;100;</span><br><span class="line"></span><br><span class="line">#方式二:</span><br><span class="line">ALTER VIEW test_v7</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id FROM employees;</span><br></pre></td></tr></table></figure>

<h5 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure>

<h5 id="视图的查看"><a href="#视图的查看" class="headerlink" title="视图的查看"></a>视图的查看</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式1</span><br><span class="line">DESC test_v7;</span><br><span class="line">#方式2</span><br><span class="line">SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure>







<h3 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h3><p>FROM –&gt; ON –&gt; JOIN –&gt; Where –&gt; group by –&gt; having –&gt; select –&gt; distinct –&gt; order by –&gt; limit</p>
]]></content>
  </entry>
</search>
