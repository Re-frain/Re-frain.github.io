{"meta":{"title":"re-frain","subtitle":null,"description":null,"author":"汐","url":"https://re-frain.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-25T05:46:26.000Z","updated":"2019-10-25T05:46:26.321Z","comments":true,"path":"categories/index.html","permalink":"https://re-frain.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-25T05:43:21.000Z","updated":"2019-10-25T05:43:21.573Z","comments":true,"path":"tags/index.html","permalink":"https://re-frain.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据仓库","slug":"数据仓库","date":"2019-10-31T01:42:20.000Z","updated":"2019-10-31T01:43:53.816Z","comments":true,"path":"2019/10/31/数据仓库/","link":"","permalink":"https://re-frain.github.io/2019/10/31/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/","excerpt":"","text":"数据仓库介绍一、定义数据仓库是一个面向主题的、集成的、随时间变化的、但信息本身相对稳定的数据集合，用于对管理决策过程的支持。 二、数据仓库的四个特点 面向主题：数据仓库都是基于某个明确主题，仅需要与该主题相关的数据，其他的无关细节数据将被排除掉 集成的：从不同的数据源采集数据到同一个数据源，此过程会有一些ETL操作 随时间变化：关键数据隐式或显式的基于时间变化 数据仓库的数据是不可更新的：数据装入以后一般只进行查询操作，没有传统数据库的增删改操作。数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。 三、数据库与数据仓库的区别数据库：是一种逻辑概念，用来存放数据的仓库。通过数据库软件来实现。数据库由很多表组成，表是二维的，一张表里可以有很多字段。字段一字排开，对应的数据就一行一行写入表中。数据库的表，在于能够用二维表现多维关系。目前市面上流行的数据库都是二维数据库。如：Oracle、DB2、MySQL、Sybase、MS SQL Server等。 业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。 数据仓库：是数据库概念的升级。从逻辑上理解，数据库和数据仓库没有区别，都是通过数据库软件实现的存放数据的地方，只不过从数据量来说，数据仓库要比数据库更庞大得多。数据仓库主要用于数据挖掘和数据分析，辅助领导做决策。数据仓库的表结构是依照分析需求，分析维度，分析指标进行设计的。 总结数据库 比较流行的有：MySQL, Oracle, SqlServer等数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等。 数据库与数据仓库的区别.png 四、数据仓库的应用1.数据分析、数据挖掘、人工智能、机器学习、风险控制、无人驾驶。2.数据化运营、精准运营。3.广告精准、智能投放。 五、数据仓库架构图ODS层： 为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。一般来说ODS层的数据和源系统的数据是同构的，主要目的是简化后续数据加工处理的工作。从数据粒度上来说ODS层的数据粒度是最细的。ODS层的表通常包括两类，一个用于存储当前需要加载的数据，一个用于存储处理完后的历史数据。历史数据一般保存3-6个月后需要清除，以节省空间。但不同的项目要区别对待，如果源系统的数据量不大，可以保留更长的时间，甚至全量保存； PDW层： 为数据仓库层，PDW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。这一层的数据一般是遵循数据库第三范式的，其数据粒度通常和ODS的粒度相同。在PDW层会保存BI系统中所有的历史数据，例如保存10年的数据。 DM层： 为数据集市层，这层数据是面向主题来组织数据的，通常是星形或雪花结构的数据。从数据粒度来说，这层的数据是轻度汇总级的数据，已经不存在明细数据了。从数据的时间跨度来说，通常是PDW层的一部分，主要的目的是为了满足用户分析的需求，而从分析的角度来说，用户通常只需要分析近几年（如近三年的数据）的即可。从数据的广度来说，仍然覆盖了所有业务数据。 APP层： 为应用层，这层数据是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。从数据粒度来说是高度汇总的数据。从数据的广度来说，则并不一定会覆盖所有业务数据，而是DM层数据的一个真子集，从某种意义上来说是DM层数据的一个重复。从极端情况来说，可以为每一张报表在APP层构建一个模型来支持，达到以空间换时间的目的数据仓库的标准分层只是一个建议性质的标准，实际实施时需要根据实际情况确定数据仓库的分层，不同类型的数据也可能采取不同的分层方法。 数据仓库架构图.png 六、数据仓库技术数据仓库技术是为了有效的把操作型数据集成到统一的环境中以提供决策型数据访问的各种技术和模块的总称。所做的一切都是为了让用户更快更方便查询所需要的信息，提供决策支持。 从功能结构划分，数据仓库系统至少应该包含数据获取（Data Acquisition）、数据存储（Data Storage）、数据访问（Data Access）三个关键部分。 在国内最优秀的互联网公司里(如阿里、腾讯)，很多数据引擎是架构在数据仓库之上的(如数据分析引擎、数据挖掘引擎、推荐引擎、可视化引擎等等)。 七、数据仓库多维数据模型的基本概念 主题（Subject） 主题就是指我们所要分析的具体方面。例如：某年某月某地区某机型某款App的安装情况。主题有两个元素：一是各个分析角度（维度），如时间位置；二是要分析的具体量度，该量度一般通过数值体现，如App安装量。 维（Dimension） 维是用于从不同角度描述事物特征的，一般维都会有多层（Level：级别），每个Level都会包含一些共有的或特有的属性（Attribute）。 以时间维为例，时间维一般会包含年、季、月、日这几个Level，每个Level一般都会有ID、NAME、DESCRIPTION这几个公共属性，这几个公共属性不仅适用于时间维，也同样表现在其它各种不同类型的维。 分层（Hierarchy） OLAP需要基于有层级的自上而下的钻取，或者自下而上地聚合。所以我们一般会在维的基础上再次进行分层，维、分层、层级的关系如下图： 分层.png 每一级之间可能是附属关系（如市属于省、省属于国家），也可能是顺序关系（如天周年）。 量度 量度就是我们要分析的具体的技术指标，诸如年销售额之类。它们一般为数值型数据。我们或者将该数据汇总，或者将该数据取次数、独立次数或取最大最小值等，这样的数据称为量度。 粒度数据的细分层度，例如按天分按小时分。 事实表和维表 事实表是用来记录分析的内容的全量信息的，包含了每个事件的具体要素，以及具体发生的事情。事实表中存储数字型ID以及度量信息。 维表则是对事实表中事件的要素的描述信息，就是你观察该事务的角度，是从哪个角度去观察这个内容的。 事实表和维表通过ID相关联，如图所示： 事实表和维表.png 企业级数据仓库/数据集市 企业级数据仓库：突出大而全，不论是细致数据和聚合数据它全都有，设计时使用事实星座模式. 数据集市：可以看做是企业级数据仓库的一个子集，它是针对某一方面的数据设计的数据仓库，例如为公司的支付业务设计一个单独的数据集市。由于数据集市没有进行企业级的设计和规划，所以长期来看，它本身的集成将会极其复杂。其数据来源有两种，一种是直接从原生数据源得到，另一种是从企业数据仓库得到。","categories":[],"tags":[]},{"title":"Mysql数据库（基础）","slug":"Mysql数据库(基础篇)","date":"2019-10-25T13:52:16.000Z","updated":"2019-10-25T14:54:01.208Z","comments":true,"path":"2019/10/25/Mysql数据库(基础篇)/","link":"","permalink":"https://re-frain.github.io/2019/10/25/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/","excerpt":"","text":"数据库相关概念1、DB：数据库，保存一组有组织的数据的容器。​2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据，常见的DBMS为MySql,Oracle,SqlServer,DB2。。。​3、SQL:结构化查询语言，用于和DBMS通信的语言。 MySQL产品的介绍和安装MySQL服务的启动和停止​ 方式一：计算机——右击管理——服务​ 方式二：通过管理员身份运行​ net start 服务名（启动服务）​ net stop 服务名（停止服务） MySQL服务的登录和退出123456789方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码例如： mysql -u root -p123456退出：exit或ctrl+C MySQL的常见命令12345678910111213141516171819202122232425262728291.查看当前所有的数据库show databases;2.打开指定的库use 库名;3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型， ...);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V MySQL的语法规范​ 1.不区分大小写,但建议关键字大写，表名、列名小写。​ 2.每条命令最好用分号结尾。​ 3.每条命令根据需要，可以进行缩进或换行。 12单行注释：#注释文字 -- 注释文字 (注意中间要带有一个空格才能生效)多行注释：/* 注释文字 */ SQL的语言分类1.DQL（Data Query Language)：数据查询语言 select2.DML (Data Manipulate Language): 数据操作语言 insert 、update、delete3.DDL（Data Define Languge)：数据定义语言 create、drop、alter4.TCL （Transaction Control Language)：事务控制语言 commit、rollback、savepoint 5.DCL（Data Control Language)：数据控制语言 grant、revoke DQL语言的学习基础查询123#语法：查询表的所有数据: SELECT * FROM 表名; 查询表中指定字段的值: SELECT 字段1,字段2...字段n FROM 表名; 特点：①通过select查询完的结果 ,是一个虚拟的表格，不是真实存在。②要查询的东西可以是常量值、可以是表达式、可以是字段、可以是函数。 4 使用别名12345#给查询结果中的字段使用别名字段名 as 别名或者字段名 &quot;别名&quot;SELECT name as &quot;花名&quot; FROM flower; 注意: as可以省略不写，别名中没有特殊字符，双引号也可以省略不写。 去除重复1SELECT DISTINCT 字段1,字段2...字段n FROM 表名; 注意：去除重复的规则是按照行进行去除的,多行数据完全相同取其一,DISTINCT必须放在要查询字段的开头。 +号12345678910111213#仅仅只有一个功能:运算符#两个操作数为数值型，则做加法运算SELECT 100+90; -- 190#只要其中一方为字符型，试图将字符型数值转换成数值型 #1.如果转换成功,则继续做加法运算#2.如果转换失败,则将字符型数值转换为0SELECT &quot;100&quot;+90; -- 190SELECT &quot;Tom&quot;+90; -- 90#只要其中一方为null,则结果肯定为nullSELECT null+90; -- null concat实现拼接操作12345#使用方法 CONCAT(str1,str2...) SELECT CONCAT(1,3,4); 测试 -- 一个数字参数被转化为与之相等的二进制字符串格式SELECT CONCAT(id,&apos;,&apos;,name) &quot;编号,花名&quot; from flower; 注意:返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。 条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据。 12语法：select 要查询的字段|表达式|常量值|函数 from 表名 where 筛选条件; 一、条件表达式条件运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != 二、逻辑表达式逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false。 or (||)：两个条件只要有一个成立，结果为true，否则为false。 not (!)：如果条件成立，则not后为false，否则为true。 ​ 三、模糊查询 %： 代替0个或多个任意字符。 _ ：代替1个任意字符。 1234SELECT * From flower where name like &apos;_a%&apos;;#转义关键词 ESCAPESELECT * From flower where name like &apos;_\\_%&apos;;SELECT * From flower where name like &apos;_$_%&apos; ESCAPE &apos;$&apos;; 四、关键字 between and1234#包含两头的数据 [ , ]SELECT * From emp where sal &gt;=200 and sal&lt;=300;#等价与SELECT * From emp where sal between 200 and 300; 五、关键字 in含义:判断某字段的值是否属于in列表中的某一项。 123#格式in (目标值1，目标值2，...) -- in 中的内容只能为一个字段的值,目标值之间必须使用逗号分隔,并且括在括号中。SELECT * From emp where job in (&apos;Salesman&apos;,&apos;manager&apos;,&apos;analyst&apos;); 六、关键字 is null , is not null1234#格式 SELECT * FROM 表名 WHERE 字段名 is null; -- 字段值为NullSELECT * FROM 表名 WHERE 字段名 is not null; -- 字段值不为NullSELECT * FROM emp WHERE comm is not null; -- 字段值不为Null 注意: 不能使用=,&lt;&gt;来判断NULL值。 七、安全等于 &lt;=&gt;1SELECT * FROM flower WHERE production &lt;=&gt; null; is null : 仅仅可以判断NULL值，可读性高,建议使用。 &lt;=&gt; : 既可以判断NULL值,又可以判断普通数值，可读性较低。 排序查询123456#语法#单字段排序select 要查询的东西 from 表名 where 筛选条件 order by 排序的字段|表达式|函数|别名 [asc|desc]#多字段排序select 要查询的东西 from 表名 where 筛选条件 order by 字段名1 [asc|desc],字段名2 [asc|desc]... 注意: 1.asc代表的是升序,desc代表的是降序,如果不写,默认为升序。 2.order by 子句中可以支持单个字段,多个字段,表达式,函数,别名。 3.order by 子句一般是放在查询语句的最后面,limit子句除外。 常见函数一、单行函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#用法SELECT 函数名() FROM 表名 WHERE 筛选条件1、字符函数 concat 拼接 substr 截取子串 -- 注意：索引从1开始 upper 转换成大写 lower 转换成小写 trim 去前后指定的空格和字符 ltrim 去左边空格 rtrim 去右边空格 replace 替换 lpad 用指定的字符实现左填充指定长度 rpad 用指定的字符实现右填充指定长度 instr 返回子串第一次出现的索引 -- 如果找不到返回0 length 获取字节个数2、数学函数 round 四舍五入 rand 随机数 floor 向下取整 -- &lt;=该参数的最大整数 ceil 向上取整 -- &gt;=该参数的最小整数 mod 取余 truncate 截断 3、日期函数 now 当前系统日期+时间 curdate 当前系统日期 curtime 当前系统时间 str_to_date 将字符转换成日期 date_format 将日期转换成字符 DATEDIFF 求两个日期相差的天数 SELECT DATEDIFF(now(),&quot;1998-05-27&quot;) 4、流程控制函数 #if 处理双分支 -- if else的效果SELECT last_name,commission_pct,IF(commission_pct is null,&apos;没奖金,呵呵&apos;,&apos;有奖金,嘻嘻&apos;) 备注 FROM employees; #case语句 #1.类似 switch-case的效果 case 要判断的字段或表达式 when 常量1 then 要显示的值1或者语句1; when 常量2 then 要显示的值2或者语句2; ... else 要显示的值n或者语句n; end #例子 SELECT salary 原始工资,department_id, CASE department_id WHEN 30 THEN salary*1.1 WHEN 40 THEN salary*1.2 WHEN 50 THEN salary*1.3 ELSE salary END AS 新工资 FROM employees #2.类似 多重if case when 条件1 then 要显示的值1或者语句1; when 条件2 then 要显示的值2或者语句2; ... else 要显示的值n或者语句n; end #例子 SELECT salary , CASE WHEN salary&gt;20000 THEN &apos;A&apos; WHEN salary&gt;15000 THEN &apos;B&apos; WHEN salary&gt;10000 THEN &apos;C&apos; ELSE &apos;D&apos; END AS 工资级别 FROM employees 5、其他函数 version 版本 database 当前库 user 当前连接用户 md5(&apos;字符&apos;) 返回该字符的md5加密形式 datediff(大的日期，小的日期) 返回两个日期的时间差 ​ 二、分组函数12345sum 求和max 最大值min 最小值avg 平均值count 计算个数 特点：1、*sum,max,min,avg,count(字段名)都忽略null值，count( )不忽略null值。2、sum和 avg一般用于处理数值型；max、min、count可以处理任何数据类型。3、都可以搭配distinct使用，用于统计去重后的结果。4、count的参数可以支持：字段、常量值、* ，一般放1,建议使用 count(*)。 效率： MyISAM存储引擎下,count(*)的效率高。 InnoDB存储引擎下,count(*)和count(1)的效率差不多，比count(字段名)要高一些。 分组查询1234567891011121314151617#语法：#分组前的筛选select 查询的字段，分组函数from 表名[where 筛选条件]group by 分组的字段[order by 子句]#分组后的筛选 having 子句-- 查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资select MAX(salary),job_id from employees where commission_pct is not nullgroup by job_id having MAX(salart)&gt;12000;-- 按员工姓名的长度分组,查询每一组的员工个数，筛选员工个数&gt;5select count(*) c,LENGTH(last_name) len_name from employees group by len_name having c&gt;5;#group by,having后可以支持别名。 特点：1、支持按单个字段分组;也可以按多个字段分组,多个字段之间用逗号隔开,没有顺序要求;表达式或函数(用得较少)。2、和分组函数一同查询的字段最好是分组后的字段。3、分组筛选针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having 分组函数做条件肯定是放在having子句中。 4.查询列表必须特殊,要求是分组函数和group by后出现的字段。 多表连接查询一、分类按年代分类： sql92标准，sql99标准 按功能分类: 内连接：等值连接,非等值连接,自连接 外连接：左外连接,右外连接,全外连接 交叉连接 二、笛卡尔乘积表1有m行，表2有n行,结果为m*n行。解决办法：添加上有效的连接条件。 1select * from emp,dept; 三、sql92标准含义：1992年推出的sql语法。 仅仅支持内连接。 1234567891011121314#1.等值连接 先做笛卡尔积，然后筛选,筛选条件为等值筛选。select e.ename,e.job,d.dname from emp e,dept d where e.deptno = d.deptno;/*1.多表等值连接的结果为多表的交集部分。2.n表连接，至少需要n-1个连接条件。3.多表的顺序没有要求，一般需要为表起别名。*/#2.非等值连接select * from emp e,sqlgrade s where e.sal&gt;=s.losal and e.sal&lt;=s.hisal;#3.自连接-- 查询员工姓名,工作,薪资,及上级领导的姓名select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr=e2.empno; 四、sql99标准[推荐使用]含义：1999年推出的sql语法。支持：内连接,外连接(左外连接，右外连接),交叉连接 123456789#语法：select 查询列表from 表1 别名【inner|left [outer]|right [outer]|cross】join 表2 别名on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-- 内连接#1.等值连接select 查询列表from 表1 别名[inner] join 表2 别名on 连接条件[where 筛选条件]select e.ename,e.job,d.dname from emp einner join dept d on e.deptno = d.deptnowhere e.deptno=1001;/*1.inner可以省略。2.连接条件放在on后面,筛选条件放在where后面,提高分离性,便于阅读。*/#2.非等值连接select * from emp einner join sqlgrade s on e.sal&gt;=s.losal and e.sal&lt;=s.hisal;#3.自连接select e1.ename,e1.job,e1.sal,e2.ename from emp e1inner join emp e2 on e1.mgr=e2.empno;-- 外连接#应用场景:用于查询一个表中有，另一个表没有的记录。/*特点：1.外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的,则显示匹配的值。 如果从表中没有和它匹配的,则显示null。 外连接查询的结果=内连接+主表中有而从表没有的记录。2.左外连接：left join左边的是主表 右外连接：left join右边的是主表3.左外和右外交换两个表的顺序,可以实现同样的效果。*/#1.左外连接与右外连接-- 左外连接select e.*,d.* from emp eleft outer join dept don e.deptno = d.deptno;-- 右外连接select e.*,d.* from emp eright outer join dept don e.deptno = d.deptno;#2.交叉连接 本质就是笛卡尔积select e.*,d.* from emp ecross join dept don e.deptno=d.deptno; 五、sql92 与 sql99的比较 功能：sql99支持的较多。 可读性：sql99实现连接条件和筛选条件的分离,可读性较高。 推荐性: 建议使用sql99。 子查询含义： ​ 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询;在外面的查询语句，称为主查询或外查询。 分类： 按子查询出现的位置： 12345678910SELECT 后面： 仅仅支持标量子查询from 后面: 支持表子查询where或having后面: 标量子查询 (单行子查询) 列子查询 (多行子查询) 行子查询 (多列多行)exists 后面 (相关子查询) 表子查询 按结构集的行列数不同: 标量子查询（结果集只有一行一列） ​ 列子查询 （结果集只有一列多行） ​ 行子查询 （结果集有一行多列） ​ 表子查询 (结果集一般为多行多列） 特点： 1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空 1234567891011121314151617181920# 标量子查询-- 查询工资比Tom高的员工信息select *form empwhere sal&gt;( select sal from emp where ename = &apos;Tom&apos;);-- 查询最低工资大于50号的最低工资的部门编号和其最低工资。select min(sal),deptnofrom emp group by deptnohaving min(sal)&gt;( select min(sal) from emp where deptno=50); ② 多行子查询 结果只有一个字段但是字段有n个值。 ​ 一般搭配多行操作符使用：any、all、in、not in。 ​ any: 任意 ​ all: 所有 ​ in：表示任意存在，相当于=any。 ​ not in :相当于&lt;&gt; all。 12345678910111213141516171819202122232425262728293031323334353637#关键字 any-- 查询工资高于任意一个CLERK的所有员工信息。select * from empwhere sal &gt; any( select sal from emp where job=&apos;CLERK&apos;);#关键词 all-- 查询工资高于所有SALESMAN的员工信息。select * from emp where sal &gt; all( select sal from emp where job=&apos;SALESMAN&apos;);#关键词 in-- 查询部门号20中同部门10的雇员工作一样的雇员信息。select * from empwhere job in ( select job from emp where deptno=10) and deptno =20;-- 等价于select * from empwhere job = any( select job from emp where deptno=10) and deptno =20; 行子查询 (使用频率少) ​ 结果集一行多列或者多行多列 1234567891011121314151617#查询员工编号最小并且工资最高的员工信息。select *from empwhere empno = ( select min(empno) from emp) and sal = ( select max(sal) from emp);-- 等价于select *from empwhere (empno,sal) = ( select min(empno),max(sal) from emp); from后面的子查询 12345678910#查询每个部门的平均工资的工资等级-- 将子查询结果充当一张表,要求必须起别名select avg_dep.*,s.gradefrom ( select avg(sal) avg,deptno from emp group by deptno) avg_depinner join salgrade son avg_dep.avg between losal and hisal; exists后面的子查询 （相关子查询） EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值true或false,结果为1或0。 语法: exists (完整的查询语句) 123456789101112131415#查询有员工的部门名select d.dname from dept dwhere exists ( select * from emp e where d.deptno =e.deptno );-- 等价于select d.dname from dept dwhere d.deptno in ( select deptno from emp ); 分页查询应用场景： 实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 1.起始条目索引从0开始。 2.limit子句放在查询语句的最后 3.公式：select * from 表 limit （page-1）*size,size每页显示条目数size要显示的页数 page 12345678910111213#查询前五条员工的信息select * from emp limit 0,5;select * from emp limit 5;#查询第11条-第25条select * from emp 10,15;#有奖金的员工信息,并且工资较高的前10名显示出来select * from empwhere comm is not nullorder by sal desclimit 0,10; 联合查询引入： union 联合、合并：将多条查询语句的结果合并成一个结果。 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1、多条查询语句的查询的列数必须是一致的。2、多条查询语句的查询的列的类型几乎相同。3、union代表去重，union all代表不去重。 应用场景： 要查询的结果来自于多个表，且多个表没有直接的连接关系,但查询的信息一致时。 1234#查询中国用户中男性的信息以及外国用户中年男性的用户信息select id,cname,csex from t_ca where csex =&apos;男&apos;unionselect t_id,tname from t_ua where tGender=&apos;male&apos;; DML语言的学习插入12345#语法：-- 方式一 支持插入多行，支持子查询 insert into 表名(字段名，...) values(值1，...);-- 方式二 insert into 表名 set 列名1=值1,列名2=值2...; 特点： 1、字段类型和值类型一致或兼容，而且一一对应。2、可以为空的字段，可以不用插入值，或用null填充。3、不可以为空的字段，必须插入值。4、字段个数和值的个数必须一致。5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。 123456#方式一支持插入多行insert into beautyvalues(1603,&apos;尹远洋&apos;,&apos;男&apos;,23),(1604,&apos;张三&apos;,&apos;男&apos;,21),(1605,&apos;李丽&apos;,&apos;女&apos;,18);#支持子查询insert into beauty(id,name,age) select 1603,&apos;尹远洋&apos;,23; 修改修改单表语法： 1update 表名 set 字段=新值,字段=新值 where 筛选条件; 修改多表语法： 123456789101112#sql92语法update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件;#sql99语法update 表1 别名1inner|left|right join 表2 别名2on 连接条件set 字段=新值，字段=新值where 筛选条件; 删除方式1：delete语句单表的删除： ★ 1delete from 表名 [where 筛选条件]; 多表的删除： 123456789101112#sql92语法 delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; #sql99语法 delete 别名1，别名2 from 表1 别名1 inner|left|right join 表2 别名2 on 连接条件 where 筛选条件; 方式2：truncate语句1truncate table 表名; 两种方式的区别【面试题】 1.truncate不能加where条件，而delete可以加where条件。 2.truncate的效率高一丢丢。 3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始；delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。 4.truncate删除没有返回值，delete删除有返回值。 4.truncate删除不能回滚，delete删除可以回滚。 DDL语言的学习库和表的管理库的管理12345678#创建库create database [if not exists] 库名;#修改库 -- 目前不能用了,不安全#更改库的字符集alter database 库名 character set 字符集;#删除库drop database [if exists] 库名; 表的管理123456789101112131415161718192021222324252627282930313233343536373839404142#创建表CREATE TABLE [IF NOT EXISTS] 表名( 列名 列的类型[(长度) 约束], 列名 列的类型[(长度) 约束], ...);CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);#修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20);#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#删除表DROP TABLE [IF EXISTS] studentinfo;#表的复制-- 1.仅仅复制表的结构create table 表名 like 表名;-- 2.复制表的结构+数据create table 新表 select * from 旧表; ​ 常见的数据类型整型： tinyint、smallint、mediumint、int/Integer、bigint小数： 浮点型: float、double 定点型:dec(M,D)、decimal(M,D) ​ 特点： ​ 1.M：整数部位+小数部位 ​ D:小数部位 ​ 如果超过范围，则插入临界值。 ​ 2.M和D都可以省略，如果是decimal，则M默认为10,D默认为0。 ​ 如果是float和double,则会根据插入的数值的精度来决定精度。 ​ 3.定点型的精确度较高,如果要求插入数值的精度较高如货币运算等则考虑使用。 字符型： 较短的文本:char 、varchar 较长的文本:text、blob(较大的二进制) 写法 M的意思 特点 空间的耗费 效率 char char(M) 最大的字符数,可以省略,默认为1 固定长度的字符 比较耗费 高 varchar varchar(M) 最大的字符数,不可以省略 可变长度的字符 比较节省 低 其他： binary和varbinary用于保存较短的二进制。 enum用于保存枚举。 set用于保存集合。 日期型： 分类： ​ data:只保存日期 ​ time:只保存时间 ​ year:只保存年 ​ datetime:保存日期+时间 ​ timestamp:保存日期+时间 特点： 字节 范围 时区等的影响 datetime 8 1000-9999 不受 timestamp 4 1970-2038 受 Blob类型： ​ ·tinyblob:仅255个字符 ·blob:最大限制到65K字节 ·mediumblob:限制到16M字节 ·longblob:可达4GB 常见约束1234567NOT NULL:非空,用来保证该字段的值不能为空DEFAULT:默认,用于保证该字段有默认值UNIQUE:唯一,用于保证该字段的值具有唯一性,可以为空CHECK:检查约束 [mysql中不支持]PRIMARY KEY:主键,用于保证该字段的值具有唯一性,并且非空FOREIGN KEY:外键,用于限制两个表的关系,用于保证该字段的值必须来自于主表的关联列的值在从表添加外键约束,用于引用主表中某列的值 添加约束的时机： ​ 1.创建表时 ​ 2.修改表时 约束的添加分类： ​ 列级约束： ​ 六大约束语法上都支持,但是外键约束没有效果 ​ 表级约束： ​ 除了非空,默认,其他的都支持 12345create table 表名( 字段名 字段类型 列级约束, 字段名 字段类型, 表级约束); 列级约束 语法：直接在字段名和类型后面追加约束类型即可。 只支持:默认,非空,主键,唯一。 表级约束 支持：主键,外键,唯一 1234[constraint 约束名] 约束类型(字段名);constraint pk PRIMARY KEY(id), #主键约束UNIQUE(seat), #唯一键constraint fk_stuinfo_major FOREIGN KEY(majorid) references major(id) #外键约束 主键和唯一的区别: 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有一个 √，但不推荐 唯一 √ √ 可以有多个 √，但不推荐 外键： 1.要求在从表设置外键关系。 2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称没要求。 3.主表的关联列必须是一个key（一般是主键或者唯一)。 4.插入数据时,先插入主表,再插入从表。删除数据时,先删除从表,再删除主表。 修改表时添加约束 1.添加列级约束 1alter table 表名 modify column 字段名 字段类型 新约束; 2.添加表级约束 1alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用]; 1234567891011121314151617#添加非空约束alter table stuinfo modify column stuname varchar(20) not null;#添加默认约束alter table stuinfo modify column age int default 18;#添加主键-- 列级约束alter table stuinfo modify column id int primary key;-- 表级约束alter table stuinfo add primary key(id);#添加唯一-- 列级约束alter table stuinfo modify column seat int unique;-- 表级约束alter table stuinfo add unique(seat);#添加外键-- 表级约束alter table stuinfo add constraint fk_stuinfo_major foreign key(majorid) references major(id); 修改表时删除约束 12345678910#删除非空约束alter table stuinfo modify column stuname varchar(20) null;#删除默认约束alter table stuinfo modify column age int ;#删除主键alter table stuinfo drop primary key;#删除唯一alter table stuinfo drop index seat;#删除外键alter table stuinfo drop foreign key fk_stuinfo_major; 位置 支持的约束类型 是否可以起约束名 列级约束 列的后面 语法都支持，但外键没有效果 不可以 表级约束 所有列的下面 默认和非空不支持,其他支持 可以(主键没有效果) 标识列 又称为自增长列。含义：可以不用手动的插入值，系统提供默认的序列值。 特点: 1.标识列要求是一个key。 2.一个表至多一个标识列。 3.标识列的类型只能是数值型。 4.标识列可以通过set auto_increment_increment=数字；设置步长 可以通过手动插入值 ,设置起始。 1234create table user( id int primary key auto_increment, ...) 修改表时设置标识列: 1alter table user modify column id int primary key auto_increment; 删除表时设置标识列: 1alter table user modify column id int; 数据库事务特点(ACID):​ 原子性（Atomicity）：一个事务不可再分割,要么都执行要么都不执行。​ 一致性(Consistency)：一个事务保证数据的状态操作前和操作后保持一致。​ 隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。​ 持久性(Durability)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。 事务的分类隐式事务，没有明显的开启和结束事务的标志。 比如insert、update、delete语句本身就是一个事务。 显式事务，具有明显的开启和结束事务的标志。 前提：必须先设置自动提交功能为禁用。 set autocommit=0; 12345678910111213#步骤1:开启事务set autocommit=0;start transaction; #可选的 #步骤2.编写事务的一组逻辑操作单元（多条sql语句） select insert update delete #步骤3.提交事务或回滚事务 commit; 提交事务 rollback; 回滚事务 使用到的关键字123456789101112131415set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点#演示savepoint的使用set autocommit=0;start transaction;delete from account where id=25;savepoint a;-- 设置保持点adelete from account where id=28;rollback to a; -- 回滚到保持点a 事务的隔离级别事务并发问题如何发生当多个事务同时操作同一个数据库的相同数据时。 事务的并发问题有哪些1、脏读脏读是指并发过程中，一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下： 123update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 2、不可重复读 不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。 3、幻读 幻读是事务非独立执行时发生的一种现象。例如事务T1查询整张表中有多少条记录，这时事务T2又对这个表中插入了一行数据。而操作事务T1的用户如果再查看整张表有多少行数据，会发现多出一行数据，其实这行是事务T2添加的，就好像产生幻觉一样，这就是发生了幻读。 不可重复读和脏读的区别是:脏读是某一事务读取了另一个事务未提交的脏数据。 不可重复读则是两次读取之间存在另一个事务提交的数据。 幻读和不可重复读区别是： 不可重复读的重点是修改（update），操作的是某一行数据，需要锁行。同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。 幻读的重点在于新增（insert）或者删除（delete），操作的是整张表，需要锁表。同样的条件, 第1次和第2次读出来的记录数不一样。 如何避免事务的并发问题通过设置事务的隔离级别:1、READ UNCOMMITTED（读未提交）2、READ COMMITTED（读已提交） 可以避免脏读3、REPEATABLE READ（可重复读） 可以避免脏读、不可重复读和一部分幻读 (默认)4、SERIALIZABLE (串行化) 可以避免脏读、不可重复读和幻读 设置隔离级别1set session|global transaction isolation level 隔离级别名; 查看隔离级别1select @@tx_isolation; 视图含义：理解成一张虚拟的表。 视图和表的区别： 使用方式 占用物理空间 视图 增删改查，一般不做增删改 create view 不占用，仅仅保存的是sql逻辑 表 增删改查 create table 占用 视图的好处： 1、sql语句提高重用性，简化复杂的sql操作，效率高。2、和表实现了分离，保护数据,提高了安全性。 视图的创建语法： 123CREATE VIEW 视图名 AS查询语句; 视图中数据增删改查12345678910111213#1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;#一般不更改视图里面的数据#2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);#3、修改视图的数据UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;#4、删除视图的数据DELETE FROM my_v4; 某些视图不能更新​ 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all​ 常量视图​ Select中包含子查询​ join​ from一个不能更新的视图​ where子句的子查询引用了from子句中的表 视图的更新12345678910#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees; 视图的删除1DROP VIEW test_v1,test_v2,test_v3; 视图的查看1234#方式1DESC test_v7;#方式2SHOW CREATE VIEW test_v7; 查询顺序FROM –&gt; ON –&gt; JOIN –&gt; Where –&gt; group by –&gt; having –&gt; select –&gt; distinct –&gt; order by –&gt; limit","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2019-10-20T13:30:39.000Z","updated":"2019-10-24T02:41:02.219Z","comments":true,"path":"2019/10/20/我的第一篇博客文章/","link":"","permalink":"https://re-frain.github.io/2019/10/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"1024程序员节快乐","categories":[],"tags":[]}]}