{"meta":{"title":"re-frain","subtitle":null,"description":null,"author":"汐","url":"https://re-frain.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-25T05:46:26.000Z","updated":"2019-10-25T05:46:26.321Z","comments":true,"path":"categories/index.html","permalink":"https://re-frain.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-25T05:43:21.000Z","updated":"2019-11-18T03:16:31.176Z","comments":true,"path":"tags/index.html","permalink":"https://re-frain.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis","slug":"Mybatis","date":"2019-12-03T03:31:10.551Z","updated":"2019-12-04T14:39:50.678Z","comments":true,"path":"2019/12/03/Mybatis/","link":"","permalink":"https://re-frain.github.io/2019/12/03/Mybatis/","excerpt":"","text":"MyBatis第1章 MyBatis 简介1.1 MyBatis历史1.MyBatis 是 Apache 的一个开源项目 iBatis, 2010 年 6 月这个项目由 Apache Software Foundation 迁移到了 Google Code，随着开发团队转投 Google Code 旗下， iBatis3.x 正式更名为 MyBatis ，代码于 2013 年 11 月迁移到 Github 。 2.iBatis 一词来源于“internet”和“abatis”的组合，是一个基于 Java 的持久层框架。 iBatis 提供的持久层框架包括 SQL Maps 和 Data Access Objects（DAO）。 1.2 MyBatis简介1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的 Java 对象）映射成数据库中的记录。 4 ) 半自动的持久化层框架,轻量级框架,SQL映射框架。 1.3 为什么要使用 MyBatis1) JDBC 1.SQL 夹在 Java 代码块里，耦合度高导致硬编码内伤。 2.维护不易且实际开发需求中 sql 是有变化，频繁修改的情况多见。 2) Hibernate 和 JPA 1.长难复杂 SQL，对于 Hibernate 而言处理也不容易。 2.内部自动生产的 SQL，不容易做特殊优化。 3.基于全映射的全自动框架,大量字段的 POJO 进行部分映射时比较困难,导致数据库性能下降。 3） MyBatis 1.对开发人员而言，核心 sql 还是需要自己优化。 2.sql 和 java 编码分开，功能边界清晰，一个专注业务、一个专注数据。 1.4 Mybatis的下载地址:https://github.com/mybatis/mybatis-3/releases 第2章 MyBatis的使用2.1 开发环境的准备​ 导入 MyBatis 框架的 jar 包、Mysql 驱动包、log4j 的 jar 包,导入log4j的配置文件。 2.2 创建测试表2.3 创建javaBean2.4 创建MyBatis的全局配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;properties resource=\"dbconfig.properties\"&gt; &lt;/properties&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;/settings&gt; &lt;environments default=\"d_oracle\"&gt; &lt;environment id=\"d_mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"d_oracle\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;oracle.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;oracle.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;oracle.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;oracle.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;property name=\"MySQL\" value=\"mysql\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\"/&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt; &lt;/databaseIdProvider&gt; &lt;mappers&gt; &lt;package name=\"com.yyy.mapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/People?allowMultiQueries=truejdbc.username=rootjdbc.password=123456 2.5 Mapper 接口开发1.编写接口 123public interface PeopleMapper &#123; public abstract List&lt;People&gt; SelAll();&#125; 2.完成两个绑定 —Mapper 接口与 Mapper 映射文件的绑定,在 Mppper 映射文件中的&lt;mapper&gt;标签中的 namespace 中必须指定 Mapper 接口的全类名。 —Mapper 映射文件中的增删改查标签的 id 必须指定成 Mapper 接口中的方法名。 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.yyy.mapper.PeopleMapper\"&gt; &lt;select id=\"SelAll\" resultType=\"com.yyy.entity.People\"&gt; select * from people &lt;/select&gt;&lt;/mapper&gt; 2.6 测试12345InputStream is = Resources.getResourceAsStream(\"Mybatis.xml\");SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);SqlSession session = factory.openSession();PeopleMapper mapper = session.getMapper(PeopleMapper.class);List&lt;People&gt; list =mapper.SelAll(); 第3章 MyBatis全局配置文件3.1 MyBatis全局配置文件简介1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 文件结构如下: configuration（配置） properties（属性） settings（设置） typeAliases（类型别名) typeHandlers（类型处理器） objectFactory（对象工厂) plugins（插件) environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器) 3.2 properties 属性​ 可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来配置。 123456&lt;properties&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/testMybatis\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/properties&gt; 然而 properties 的作用并不单单是这样，你可以创建一个资源文件，名为 dbconfig.properties 的文件,将四个连接字符串的数据在资源文件中通过键值对(key=value)的方式放置，不要任何符号，一条占一行。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testMybatisjdbc.username=rootjdbc.password=123456 在myBatis全局配置文件中: 1234567891011121314151617&lt;!-- mybatis可以使用properties来引用外部properties配置文件的内容 resource:引入类路径下的资源 url:引入网络路径或者自盘路径下的资源。 --&gt; &lt;properties resource=\"dbconfig.properties\"&gt;&lt;/properties&gt; &lt;environments default=\"default\"&gt; &lt;environment id=\"default\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 3.3 settings设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 设置名 描述 有效值 默认值 cacheEnabled 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false aggressiveLazyLoading 当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。 true | false false （在 3.4.1 及之前的版本默认值为 true） multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要驱动支持）。 true | false true useColumnLabel 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 true | false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。 true | false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出提醒日志 (&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39; 的日志等级必须设置为 WARN)FAILING: 映射失败 (抛出 SqlSessionException) NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 任意正整数 未设置 (null) defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 任意正整数 未设置 (null) defaultResultSetType Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2) FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(same behavior with ‘Not Set’) Not Set (null) safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 true | false False safeResultHandlerEnabled 允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。 true | false True mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true | false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION | STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL, VARCHAR 或 OTHER。 OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 用逗号分隔的方法列表。 equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 一个类型别名或完全限定类名。 org.apache.ibatis.scripting.xmltags.XMLLanguageDriver defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） 一个类型别名或完全限定类名。 org.apache.ibatis.type.EnumTypeHandler callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值初始化的时候比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true | false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 （如集合或关联）。（新增于 3.4.2） true | false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 未设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 CGLIB | JAVASSIST JAVASSIST （MyBatis 3.3 以上） vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 未设置 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） true | false true configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） 类型别名或者全类名. 未设置 3.4 typeAliaes 别名处理​ 类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 1&lt;typeAliases&gt; &lt;typeAlias type=\"com.yyy.Employee\" alias=\"emp\"/&gt; &lt;/typeAliases&gt; 类很多的情况下，可以批量设置别名这个包下的每一个类创建一个默认的别名,在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 123&lt;typeAliases&gt; &lt;package name=\"com.yyy.entity\"/&gt; &lt;/typeAliases&gt; 若有注解，则别名为其注解值。 1234@Alias(\"emp\")public class Employee&#123; ...&#125; 这是一些为常见的 Java 类型内建的相应的类型别名。它们都是不区分大小写的，注意对基本类型名称重复采取的特殊命名风格。 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 3.5 typeHandlers 类型处理器​ 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 提示:从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SMALLINT IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 BIGINT FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobReaderTypeHandler java.io.Reader - ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB BlobInputStreamTypeHandler java.io.InputStream - ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR 或任何兼容的字符串类型，用以存储枚举的名称（而不是索引值） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的序数值（而不是名称）。 SqlxmlTypeHandler java.lang.String SQLXML InstantTypeHandler java.time.Instant TIMESTAMP LocalDateTimeTypeHandler java.time.LocalDateTime TIMESTAMP LocalDateTypeHandler java.time.LocalDate DATE LocalTimeTypeHandler java.time.LocalTime TIME OffsetDateTimeTypeHandler java.time.OffsetDateTime TIMESTAMP OffsetTimeTypeHandler java.time.OffsetTime TIME ZonedDateTimeTypeHandler java.time.ZonedDateTime TIMESTAMP YearTypeHandler java.time.Year INTEGER MonthTypeHandler java.time.Month INTEGER YearMonthTypeHandler java.time.YearMonth VARCHAR 或 LONGVARCHAR JapaneseDateTypeHandler java.time.chrono.JapaneseDate DATE 1.日期和时间的处理，JDK1.8 以前一直是个头疼的问题。我们通常使用 JSR310 规范领导者 Stephen Colebourne 创建的 Joda-Time 来操作。1.8 已经实现全部的 JSR310 规范了 2.日期时间处理上，我们可以使用 MyBatis 基于 JSR310（Date and Time API）编写的各种日期时间类型处理器。 3.MyBatis3.4 以前的版本需要我们手动注册这些处理器，以后的版本都是自动注册的。 4.自定义类型转化器 我们可以重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。 步骤： ​ 实 现 org.apache.ibatis.type.TypeHandler 接 口 或 者 继 承org.apache.ibatis.type.BaseTypeHandler ​ 指定其映射某个 JDBC 类型（可选操作） ​ 在 mybatis 全局配置文件中注册 3.6 objectFactory 对象工厂​ MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。 3.7 plugins 插件​ 插件是 MyBatis 提供的一个非常强大的机制，我们可以通过插件来修改 MyBatis 的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。 四大对象: 1.Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) 2.ParameterHandler (getParameterObject, setParameters) 3.ResultSetHandler (handleResultSets, handleOutputParameters) 4.StatementHandler (prepare, parameterize, batch, update, query) 3.8 enviroments 配置环境​ MyBatis 可以配置多种环境，比如开发、测试和生产环境需要有不同的配置 ,每种环境使用一个 environment 标签进行配置并指定唯一标识符,可以通过environments标签中的default 属性指定一个环境的标识符来快速的切换环境。 12345678910111213141516171819202122232425&lt;!-- environment指定具体环境 id：指定当前环境的唯一标识 transactionManager和 dataSource 都必须有--&gt;&lt;environments default=\"default\"&gt; &lt;environment id=\"default\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/people\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 3.8.1 transactionManager 事务管理器在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）： 1.JDBC​ 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 2.MANAGED​ 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 1&lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; 3.8.2 dataSource 数据源dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）： 1.UNPOOLED​ 这个数据源的实现只是每次被请求时打开和关闭连接。虽然有点慢，但对于在数据库连接可用性方面没有太高要求的简单应用程序来说，是一个很好的选择。 不同的数据库在性能方面的表现也是不一样的，对于某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。 2.POOLED​ 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 3.JNDI​ 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 3.8.3 提示​ 如果你正在使用 Spring + MyBatis，我们使用 Spring 管理数据源,并进行事务控制的配置来覆盖上述配置。 3.9 databaseIdProvider 数据库厂商标识​ MyBatis 可以根据不同的数据库厂商执行不同的语句。 1234567891011&lt;!-- Type： DB_VENDOR, 使用 MyBatis 提供的 VendorDatabaseIdProvider 解析数据库厂商标识。也可以实现 DatabaseIdProvider 接口来自定义. 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短. Property-name：数据库厂商标识 Property-value：为标识起一个别名，方便 SQL 语句使用 databaseId 属性引用--&gt;&lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;property name=\"MySQL\" value=\"mysql\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\"/&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt; &lt;/databaseIdProvider&gt; 12345678910&lt;!-- 配置了databaseIdProvider后，在SQL映射文件中的增删改查标签中使用 databaseId 来指定数据库标识的别名。--&gt;&lt;select id=\"getEmployeeById\" resultType=\"com.yyy.Employee\" databaseId=\"mysql\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;select id=\"getEmployeeById\" resultType=\"com.yyy.Employee\" databaseId=\"oracle\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; MyBatis 匹配规则如下: 1.如果没有配置 databaseIdProvider 标签，那么 databaseId=null 。 2.如果配置了 databaseIdProvider 标签，使用标签配置的 name 去匹配数据库信息，匹配上设置 databaseId=配置指定的值，否则依旧为 null。 3.如果 databaseId 不为 null，他只会找到配置 databaseId 的 sql 语句。 4.MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 3.10 mappers 映射器1.用来在 mybatis 初始化的时候，告诉 mybatis 需要引入哪些 Mapper 映射文件。 2.mapper 逐个注册 SQL 映射文件 12345678&lt;!-- resource : 引入类路径下的文件 url : 引入网络路径或者是磁盘路径下的文件 class : 引入 Mapper 接口--&gt;&lt;mappers&gt; &lt;mapper resource=\"com/yyy/mapper/FlowerMapper.xml\"/&gt;&lt;/mappers&gt; 有 SQL 映射文件 , 要求 Mapper 接口与 SQL 映射文件同名同位置。 没有 SQL 映射文件 , 使用注解在接口的方法上写 SQL 语句。 3.使用批量注册，这种方式要求 SQL 映射文件名必须和接口名相同并且在同一目录下 123&lt;mappers&gt; &lt;package name=\"com.yyy.mapper\"/&gt; &lt;/mappers&gt; 第4章 MyBatis SQL映射文件4.1 MyBatis映射文件简介1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 1.MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 2.SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 4.2 Mybatis CRUD4.2.1 select12345678910&lt;!-- Mapper接口方法 public People queryPeoById(int id); 查询不需要写参数类型parameterType namespace:全类名--&gt; &lt;mapper namespace=\"com.yyy.mapper.PeopleMapper\"&gt; &lt;select id=\"queryPeoById\" resultType=\"com.yyy.entity.People\"&gt; select * from people where id=#&#123;id&#125; &lt;/select&gt; select元素的属性 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler） 推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 fetchSize 这是一个给驱动的提示，尝试让驱动程序每次批量返回的结果行数和这个设置值相等。 默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 中的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用。它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。 4.2.2 insert12345678&lt;!-- Mapper接口方法: public int addPeo(People people); 增删改不需要写参数类型(parameterType)与返回类型(resultType)--&gt;&lt;insert id=\"addPeo\"&gt; insert into people(id,name,age) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&lt;/insert&gt; 4.2.3 update12345678&lt;!-- Mapper接口方法: public int alterPeoById(People people); 增删改不需要写参数类型(parameterType)与返回类型(resultType)--&gt;&lt;update id=\"alterPeoById\"&gt; update people set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;&lt;/update&gt; 4.2.4 delete12345678&lt;!-- Mapper接口方法: public int delPeoById(People people); 增删改不需要写参数类型(parameterType)与返回类型(resultType)--&gt;&lt;delete id=\"delPeoById\"&gt; delete from people where id=#&#123;id&#125;&lt;/delete&gt; insert,update,delete元素的属性 属性 描述 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。请使用内联参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true（对于 insert、update 和 delete 语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望使用多个生成的列，也可以设置为逗号分隔的属性名称列表。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 4.3 主键生成方式、获取主键值4.3.1 主键生成方式1) 支持主键自增，例如 MySQL 数据库 2) 不支持主键自增，例如 Oracle 数据库 4.3.2 获取主键值1) 若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上。 123456789&lt;insert id=\"addPeo\" useGeneratedKeys=\"true\" keyProperty=\"id\" databaseId=\"mysql\"&gt; insert into people(name,age) values(#&#123;name&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;!-- 测试: People people =new People(\"test1\",20); int addPeoById = mapper.addPeo(people); System.out.println(people.getId());--&gt; 2) 而对于不支持自增型主键的数据库（例如 Oracle），则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用 。 123456789101112131415161718&lt;!-- order 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先生成主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。--&gt;&lt;insert id=\"insertEmployee\" databaseId=\"oracle\"&gt; &lt;selectKey order=\"BEFORE\" keyProperty=\"id\" resultType=\"integer\"&gt; select employee_seq.nextval from dual &lt;/selectKey&gt; insert into orcl_employee(id,last_name,email,gender) values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; &lt;insert id=\"insertEmployee\" databaseId=\"oracle\"&gt; &lt;selectKey order=\"AFTER\" keyProperty=\"id\" resultType=\"integer\"&gt; select employee_seq.currval from dual &lt;/selectKey&gt; insert into orcl_employee(id,last_name,email,gender) values(employee_seq.nextval,#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;) &lt;/insert&gt; 4.4 参数传递4.4.1 参数传递的方式1.单个参数​ 基本类型： ​ 取值：#{随便写} ​ 对象类型： ​ 取值: #{属性名} 2.多个参数​ 只要传入了多个参数,MyBatis会自动将这些参数封装在一个map中,map 的 key 是 param1，param2…或者 0,1…,值就是参数的值 。 ​ 取值: #{0},#{1}… #{param1},#{param2} 3.命名参数​ 为参数使用@Param 起一个名字，MyBatis 就会将这些参数封装进 map 中，key 就是我们自己指定的名字。 1public People SelBYNameAge(@Param(\"name\")String name ,@Param(\"age\")int age); 123&lt;select id=\"SelBYNameAge\" resultType=\"com.yyy.entity.People\"&gt; select * from people where name=#&#123;name&#125; and age=#&#123;age&#125;&lt;/select&gt; 4.POJO​ 当这些参数属于我们业务 POJO 时，我们直接传递 POJO。 ​ 取值:#{属性名} 5.Map​ 我们也可以封装多个参数为 map，直接传递。 ​ 取值:#{key} 6.Collection/Array​ 会被 MyBatis 封装成一个 map 传入, Collection 对应的 key 是 collection,Array 对应的 key 是 array. 如果确定是 List 集合，key 还可以是 list. 4.4.2 参数处理参数位置支持的属性: javaType、jdbcType、mode、numericScale、resultMap、typeHandler、jdbcTypeName、 expression 实际上通常被设置的是：jdbcType 12id=#&#123;id,jdbcType=INT&#125;//万一传入的数据是null,mysql插入null没问题,oracle有问题。 *4.4.3 *参数的获取方式1.#{属性名}​ 是参数预编译的方式,参数的位置都是用?替代,参数后来都是预编译设置进去的,安全,不会有sql注入。 2.${属性名}​ 不是参数预编译,而是直接和sql语句进行拼接,不安全。 ​ 使用场景: select * from ${tableName} order by ${columnName} 4.5 查询的几种情况4.5.1.查询单行数据返回单个对象1234&lt;!-- public Employee getEmployeeById(Integer id); --&gt;&lt;select id=\"getEmployeeById\" resultType=\"com.yyy.entity.Employee\"&gt; select * from employee where id =#&#123;id&#125;&lt;/select&gt; 4.5.2.查询多行数据返回List集合1234&lt;!-- public List&lt;Employee&gt; getAllEmps(); --&gt;&lt;select id=\"getAllEmps\" resultType=\"com.yyy.entity.Employee\"&gt; select * from employee &lt;/select&gt; 4.5.3.查询单行数据返回Map集合1234&lt;!-- public Map&lt;String,Object&gt; getEmployeeByIdReturnMap(Integer id); --&gt;&lt;select id=\"getEmployeeByIdReturnMap\" resultType=\"map\"&gt; select * from employee where id=#&#123;id&#125;&lt;/select&gt; 4.5.4.查询多行数据返回Map集合1234567&lt;!-- public Map&lt;Integer,Employee&gt; getAllEmpsReturnMap(); --&gt;&lt;select id=\"getAllPeoReturnMap\" resultType=\"com.yyy.entity.People\" &gt; select * from people &lt;/select&gt;@MapKey(\"id\")Map&lt;Integer, Object&gt; getAllPeoReturnMap(); 4.6 resultType 自动映射1) autoMappingBehavior 默认是 PARTIAL，开启自动映射的功能。唯一的要求是列名和javaBean 属性名一致 2) 如果 autoMappingBehavior 设置为 null 则会取消自动映射。 3) 数据库字段命名规范，POJO 属性符合驼峰命名法，如 A_COLUMN aColumn，我们可以开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true。 4.7 resultMap 自定义映射1) 自定义 resultMap,实现高级结果集映射 2) id ：用于完成主键值的映射 3) result ：用于完成普通列的映射 4) association ：一个复杂的类型关联;许多结果将包成这种类型 5) collection ： 复杂类型的集 4.7.1 id&amp;resultid和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。 这两者之间的唯一不同是，id 元素表示的结果将是对象的标识属性，这会在比较对象实例时用到。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 属性 描述 property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面W讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 123456789101112&lt;mapper namespace=\"com.yyy.mapper.CatMapper\"&gt; &lt;select id=\"selAll\" resultType=\"com.yyy.entity.Cat\" resultMap=\"test\"&gt; &lt;!-- select cid id ,cname name ,cage age,cgender gender from cat --&gt; select cid,cname,cage,cgender from cat &lt;/select&gt; &lt;resultMap type=\"com.yyy.entity.Cat\" id=\"test\"&gt; &lt;id column=\"cid\" property=\"id\"/&gt; &lt;result column=\"cname\" property=\"name\"/&gt; &lt;result column=\"cage\" property=\"age\"/&gt; &lt;result column=\"cgender\" property=\"gender\"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 4.7.2 association​ POJO 中的属性可能会是一个对象,我们可以使用联合查询，并以级联属性的方式封装对象,使用 association 标签定义对象的封装规则。 1234567891011121314151617&lt;!-- 使用级联方式--&gt;&lt;mapper namespace=\"com.yyy.mapper.EmpMapper\"&gt; &lt;select id=\"SelById\" resultMap=\"test\"&gt; select e.empno,e.ename,e.sal,d.deptno,d.dname from emp e left join dept d on e.deptno =d.deptno where empno=#&#123;id&#125; &lt;/select&gt; &lt;resultMap type=\"com.yyy.entity.Emp\" id=\"test\"&gt; &lt;id property=\"empno\" column=\"empno\"&gt;&lt;/id&gt; &lt;result property=\"ename\" column=\"ename\"/&gt; &lt;result property=\"sal\" column=\"sal\"/&gt; &lt;result property=\"dept.deptno\" column=\"deptno\"/&gt; &lt;result property=\"dept.dname\" column=\"dname\"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 123456789101112131415161718&lt;!-- 使用association --&gt;&lt;mapper namespace=\"com.yyy.mapper.EmpMapper\"&gt; &lt;select id=\"SelById\" resultMap=\"demo\"&gt; select e.empno,e.ename,e.sal,d.deptno,d.dname from emp e left join dept d on e.deptno =d.deptno where empno=#&#123;id&#125; &lt;/select&gt; &lt;resultMap type=\"com.yyy.entity.Emp\" id=\"demo\"&gt; &lt;id property=\"empno\" column=\"empno\"&gt;&lt;/id&gt; &lt;result property=\"ename\" column=\"ename\"/&gt; &lt;result property=\"sal\" column=\"sal\"/&gt; &lt;association property=\"dept\" javaType=\"com.yyy.entity.Dept\"&gt; &lt;id property=\"deptno\" column=\"deptno\"/&gt; &lt;result property=\"dname\" column=\"dname\" /&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 4.7.3 association 分步查询4.7.4 collection4.7.3 collection 分步查询第5章 动态SQL5.1 动态sql的简介1) 动态 SQL 是 MyBatis 强大特性之一,极大的简化我们拼装 SQL 的操作 。 2) 动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似 。 3) MyBatis 采用功能强大的基于 OGNL 的表达式来简化操作: ​ if ​ choose (when, otherwise) ​ trim (where, set) ​ foreach 4) OGNL（ Object Graph Navigation Language ）对象图导航语言，这是一种强大的表达式语言，通过它可以非常方便的来操作对象属性。 类似于我们的 EL，SpEL 等。 访问对象属性： person.address.city 调用方法： person.getName() 调用静态属性/方法： @java.lang.Math@PI 调用构造方法： new com.atguigu.bean.Person(“admin”).name 运算符： +,-*,/,% 逻辑运算符： in,not in,&gt;,&gt;=,&lt;,&lt;=,==,!= 注意：xml 中特殊符号如”,&gt;,&lt;等这些都需要使用转义字符。 5.2 if 、where标签if 用于完成简单的判断,Where 用于解决 SQL 语句中 where 关键字以及条件中第一个 and 或者 or 的问题。 123456789101112131415161718192021222324&lt;!-- where会去掉第一个and或者or mybatis做if判断 注意:下面这种写法只适用于 id 类型为字符串. &lt;if test=\"id != null and id != '' \"&gt; id = #&#123;id&#125; &lt;/if&gt; 如果id类型为int 当id=0时 这个判断不会进入. 可以这样写&lt;if test=\"id != null and id != '' or id==0\"&gt;--&gt;&lt;select id=\"SelEmp\" resultMap=\"demo\"&gt; select * from emp &lt;where&gt; &lt;if test=\"empno!=null and empno!='' \"&gt; and empno=#&#123;empno&#125; &lt;/if&gt; &lt;if test=\"ename!=null and ename!='' \"&gt; and ename=#&#123;ename&#125; &lt;/if&gt; &lt;if test=\"sal!=null and empno!=''\"&gt; and sal=#&#123;sal&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 5.3 set标签Set主要是用于解决修改操作中 SQL 语句中可能多出逗号(,)的问题。（后面的逗号） 123456789101112&lt;update id=\"UpdateEmpById\"&gt; update emp &lt;set&gt; &lt;if test=\"ename!=null and ename!=''\"&gt; ename=#&#123;ename&#125;, &lt;/if&gt; &lt;if test=\"sal!=null and sal!=''\"&gt; sal=#&#123;sal&#125;, &lt;/if&gt; &lt;/set&gt; where empno=#&#123;empno&#125; &lt;/update&gt; 5.4 choose标签​ choose 主要是用于分支判断，类似于 java 中的 switch case,只会满足所有分支中的一个。 12345678910111213141516171819&lt;select id=\"SelEmpChoose\" resultType=\"com.yyy.entity.Emp\"&gt; select * from emp &lt;where&gt; &lt;choose&gt; &lt;when test=\"empno!=null and empno!='' \"&gt; and empno=#&#123;empno&#125; &lt;/when&gt; &lt;when test=\"ename!=null and ename!=''\"&gt; and ename=#&#123;ename&#125; &lt;/when&gt; &lt;when test=\"sal!=null and sal!=''\"&gt; and sal=#&#123;sal&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 5.5 foreach标签foreach 主要用于循环迭代 : ​ collection: 要迭代的集合 ​ item: 当前从集合中迭代出的元素 ​ open: 开始字符 ​ close:结束字符 ​ separator: 元素与元素之间的分隔符 ​ index: ​ 迭代的是 List 集合: index 表示的当前元素的下标 ​ 迭代的是Map 集合: index 表示的当前元素的 key 1234567891011121314151617&lt;!-- List&lt;Emp&gt; SelEmpForeach(List&lt;Integer&gt; list); --&gt;&lt;select id=\"SelEmpForeach\" resultType=\"com.yyy.entity.Emp\"&gt; select * from emp where empno in &lt;foreach collection=\"list\" item=\"empno\" open=\"(\" close=\")\" separator=\",\"&gt; #&#123;empno&#125; &lt;/foreach&gt;&lt;/select&gt;&lt;!-- 经常这样使用 List&lt;Emp&gt; SelEmpForeach(@Param(\"empno\")List&lt;Integer&gt; list);--&gt;&lt;select id=\"SelEmpForeach\" resultType=\"com.yyy.entity.Emp\"&gt; select * from emp where empno in &lt;foreach collection=\"empno\" item=\"e\" open=\"(\" close=\")\" separator=\",\"&gt; #&#123;e&#125; &lt;/foreach&gt;&lt;/select&gt; 5.6 sql标签​ sql 标签是用于抽取可重用的 sql 片段，将相同的，使用频繁的 SQL 片段抽取出来，单独定义，方便多次引用。 1234567&lt;sql id=\"selAll\"&gt; select cid,cname,cage,cgender from cat&lt;/sql&gt;&lt;select id=\"selAll\" resultType=\"com.yyy.entity.Cat\" resultMap=\"test\"&gt; &lt;include refid=\"selAll\"&gt;&lt;/include&gt;&lt;/select&gt; 5.7 bind标签​ bind标签用于在SQL执行的上下文中绑定一个变量,方便在后续中直接使用，应用在模糊查询。 1234&lt;select id=\"SelEmpLike\" resultType=\"com.yyy.entity.Emp\"&gt; select * from emp where ename like #&#123;bindname&#125; &lt;bind name=\"bindname\" value=\" '%'+ename+'%' \"/&gt;&lt;/select&gt;","categories":[],"tags":[]},{"title":"Spring","slug":"Spring","date":"2019-11-30T13:30:55.341Z","updated":"2019-12-02T09:08:34.139Z","comments":true,"path":"2019/11/30/Spring/","link":"","permalink":"https://re-frain.github.io/2019/11/30/Spring/","excerpt":"","text":"Spring框架第1章 Spring概述1.1 Spring概述 Spring 是一个开源框架。 Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能。 Spring 是一个 IOC(DI) 和 AOP 容器框架。 具体描述 Spring: 轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API 依赖注入(DI — dependency injection、IOC) 面向切面编程(AOP — aspect oriented programming) 容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期 框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC） 1.2 Spring模块 Test: Spring的单元测试模块。 Core Container: 核心容器（IoC),黑色代表这部分的功能由哪些jar包组成,要使用这个部分的完整功能，这些jar包都需要导入。 AOP+Aspects: 面向切面编程。 Data Access/Integration: Spring数据访问模块/集成 Web: Spring开发web应用的模块。 第2章 IOC容器和Bean的配置2.1 IOC和DI2.1.1 IOC(Inversion of Control)​ 控制反转，所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。 哪些方面反转了：所依赖对象的获取被反转了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。类似容器（婚介所):主动获取变为被动接受。 2.1.2 DI(Dependency Injection)​ IOC 的另一种表述方式：依赖注入,容器动态地将某个依赖关系注入到组件之中，换句话说容器指定哪个组件运行的时候,需要另一个组件。 2.1.3 关系​ 其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 2.1.4 IOC 容器在 Spring 中的实现在通过 IOC 容器读取 Bean 的实例之前，需要先将 IOC 容器本身实例化。 只有在容器实例化后, 才可以从 IOC 容器里获取 Bean 实例并使用 Spring 提供了 IOC 容器的两种实现方式 ① BeanFactoryIOC 容器的基本实现，是 Spring 内部的基础设施，是面向 Spring 本身的，不是提供给开发人员使用的。 ② ApplicationContextBeanFactory 的子接口，提供了更多高级特性。面向 Spring 的 使 用 者 ， 几 乎 所 有 场 合 都 使 用 ApplicationContext 而 不 是 底 层 的 BeanFactory 。 ApplicationContext 的主要实现类：1.ClassPathXmlApplicationContext：从类路径(ClassPath)下加载配置文件。2.FileSystemXmlApplicationContext: 从文件系统中加载配置文件。 1ApplicationContext applicationContext =new ClassPathXmlApplicationContext(\"applicationContext.xml\"); ConfigurableApplicationContext 扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力。 AanpplicationContext 在初始化上下文时就实例化所有单例的 Bean。WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作。 ​ 2.2 从IOC容器中获取Bean​ 从 IOC 容器中获取 bean 时，除了通过 id 值获取，还可以通过 bean 的类型获取。但如 果同一个类型的 bean 在 XML 文件中配置了多个，则获取时会抛出异常，所以同一个类型的 bean 在容器中必须是唯一的。 1User user = applicationContext.getBean(User.class); 或者可以使用另外一个重载的方法，同时指定 bean 的 id 值和类型。 1User user = applicationContext.getBean(\"user\",User.class); 注: ​ 同一个组件在容器中是单实例的,容器中对象的创建在容器创建完成的时候就已经创建好了。 2.3 依赖注入的方式(基于xml配置)2.3.1 属性注入​ 属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象。使用 &lt;property&gt; 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 &lt;value&gt; 子节点指定属性值 。属性注入是实际应用中最常用的注入方式。 123456789101112131415161718//实体类Userpublic class User &#123; private int userId; private String userName; private String password; public void setUserId(int userId) &#123; this.userId = userId; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public User()&#123; super(); &#125;&#125; 1234567891011121314151617&lt;!-- applicationContext.xml 配置Bean class:bean的全类名,通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,在容器中必须是唯一的,若id没有指定,Spring自动将权限定性类名作为Bean的名字。 property有三个参数: name:属性名,在实体bean中必须有对应的setter方法,否则报错。 value:可以赋基本数据类型与String。 ref:引用外部的bean。--&gt;&lt;bean id=\"user\" class=\"com.yyy.entity.User\"&gt; &lt;property name=\"userId\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"userName\" value=\"yinyuanyang\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt; 注: ​ javaBean的属性名由setter方法(set去掉后面首字母小写)决定。 2.3.2 构造器注入​ 通过构造方法注入Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。不用为属性设置setter方法，但是需要有参构造器。 123456789101112131415//实体类Userpublic class User &#123; private int userId; private String userName; private String password; public User() &#123; super(); &#125; public User(int userId, String userName, String password) &#123; super(); this.userId = userId; this.userName = userName; this.password = password; &#125; &#125; 1234567891011121314&lt;!-- applicationContext.xml constructor-arg有5个参数: name:参数名 value:可以赋基本数据类型与String index:参数的索引,从0开始 ref:引用外部的bean type:类型(区分关键字与封装类 int Integer java.lang.String) --&gt;&lt;bean id=\"user\" class=\"com.yyy.entity.User\"&gt; &lt;constructor-arg name=\"userId\" value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"userName\" value=\"Yin\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"password\" value=\"root\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 2.3.3 工厂方法注入 不常用 2.3.4 XML 配置里的 Bean 自动装配（仅限与对自定义类型的属性)​ Spring IOC 容器可以自动装配 Bean. 需要做的仅仅是在&lt;bean&gt; 的 autowire 属性里指定自动装配的模式,autowire=”defalut/no”,不自动装配。 1.byType(根据类型自动装配)​ applicationContext.getBean(Dept.class); ​ 若 IOC 容器中有多个与目标 Bean 类型一致的 Bean. 在这种情况下, Spring 将无法判定哪个 Bean 最合适该属性, 所以不能执行自动装配. 123456789&lt;bean id=\"emp\" class=\"com.yyy.entity.Emp\" autowire=\"byType\"&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.yyy.entity.Dept\"&gt; &lt;property name=\"deptno\" value=\"11\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--结果 Emp [empno=null, ename=null, sal=0.0, dept=Dept [deptno=11, dname=root] ]--&gt; 123如果有多个与目标 Bean 类型一致的 Bean:报错信息如下：No qualifying bean of type [com.yyy.entity.Dept] is defined: expected single matching bean but found 2: dept1,dept2 2.byName(根据名称自动装配)​ applicationContext.getBean(“dept”); ​ 必须将目标 Bean 的名称和属性名设置的完全相同。 123456789&lt;bean id=\"emp\" class=\"com.yyy.entity.Emp\" autowire=\"byName\"&gt;&lt;/bean&gt;&lt;!--按照属性名(dept..)作为id去容器中找到对应id的Bean --&gt;&lt;bean id=\"dept\" class=\"com.yyy.entity.Dept\"&gt; &lt;property name=\"deptno\" value=\"11\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt;d&lt;!-- 结果： Emp [empno=null, ename=null, sal=0.0, dept=Dept [deptno=11, dname=root] ]--&gt; 12如果目标 Bean 的名称和属性名设置的不相同,找不到装配Null。Emp [empno=null, ename=null, sal=0.0, dept=null] 3.constructor(通过构造器自动装配)​ 当 Bean 中存在多个构造器时, 此种自动装配方式将会很复杂,不推荐使用。 ​ 流程: 先按照有参构造器参数的类型进行装配(成功就赋值),没有就直接为组件装配Null。 如果按照类型找到了多个,参数的名作为id继续匹配；找到就装配,没有就Null。 不会报错。 2.3.5 泛型依赖注入 2.4 p命名空间​ 为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过 &lt;bean&gt; 元素属性的方式配置 Bean 的属性。使用 p 命名空间后，基于 XML 的配置方式将进一步简化。 1&lt;bean id=\"user\" class=\"com.yyy.entity.User\" p:userId=\"1\" p:userName=\"spring\" p:password=\"123456\" /&gt; 2.5 通过注解配置Bean2.5.1 概述​ 相对于 XML 方式而言，通过注解的方式配置 bean 更加简洁和优雅，而且和 MVC 组件化开发的理念十分契合，是开发中常用的使用方式。 2.5.2 使用注解标识组件1.普通组件：@Component标识一个受 Spring IOC 容器管理的组件,当不知道一些类归到哪个层时使用,但是不建议。 2.持久化层组件：@Repository标识一个受 Spring IOC 容器管理的持久化层组件。 3.业务逻辑层组件：@Service标识一个受 Spring IOC 容器管理的业务逻辑层组件。 4.表述层控制器组件：@Controller标识一个受 Spring IOC 容器管理的表述层控制器组件。 5.组件命名规则​ ①默认情况：使用组件的简单类名首字母小写后得到的字符串作为 bean 的 id 。 ​ ②使用组件注解的 value 属性指定 bean 的 id 。 12345678910111213//id默认类名首字母小写@Repositorypublic class BookDaoImpl implements BookDao &#123;&#125;BookDaoImpl b = applicationContext.getBean(\"bookDaoImpl\",BookDaoImpl.class);//使用组件注解的 value 属性指定 bean 的 id@Repository(value=\"bookDao\")public class BookDaoImpl implements BookDao &#123;&#125;BookDaoImpl b = applicationContext.getBean(\"bookDao\",BookDaoImpl.class); 注意：事实上 Spring 并没有能力识别一个组件到底是不d是它所标记的类型，即使将 @Respository 注解用在一个表述层控制器组件上面也不会产生任何错误，所以 @Respository、@Service、@Controller 这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。 6.组件的作用域​ 默认是单例的。 1@Scope(value=\"prototype\") //多实例 2.5.3 扫描组件前提：引入context命名空间,导入aop jar包。 组件被上述注解标识后还需要通过 Spring 进行扫描才能够侦测到。 1&lt;context:component-scan base-package=\"com.yyy\"&gt;&lt;/context:component-scan&gt; 详细说明: ①base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包及其子包中的所有类。 ②当需要扫描多个包时可以使用逗号分隔。 ③如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类，示例： 1&lt;context:component-scan base-package=\"com.atguigu.component\" resource-pattern=\"autowire/*.class\"/&gt; ④包含与排除 &lt;context:include-filter&gt;子节点表示要包含的目标类 注意：通常需要与 use-default-filters 属性配合使用才能够达到“仅包含某些组件”这样的效果。即：通过将 use-default-filters 属性设置为 false,禁用默认过滤器，然后扫描的就只是 include-filter 中的规则指定的组件了。 &lt;context:exclude-filter&gt;子节点表示要排除在外的目标类 。 &lt;component-scan&gt; 下可以拥有若干个 include-filter 和 exclude-filter 子节点。 2.5.4 组件装配1.需求​ Controller 组件中往往需要用到 Service 组件的实例,Service 组件中往往需要用到 Repository 组件的实例。Spring 可以通过注解的方式帮我们实现属性的装配。 2.实现依据​ 在指定要扫描的包时,&lt;context:component-scan&gt; 元素会自动注册一个 bean 的后置处理器：AutowiredAnnotationBeanPostProcessor 的实例。该后置处理器可以自动装配标记了@Autowired、@Resource 或@Inject 注解的属性。 3.@Autowired 注解①根据类型实现自动装配。 ②构造器、普通字段(即使是非 public)、一切具有参数的方法都可以应用@Autowired 注解 。 ③默认情况下，所有使用@Autowired 注解的属性都需要被设置。当 Spring 找不到匹配的 bean 装配属性时，会抛出异常。 ④若某一属性允许不被设置，可以设置@Autowired 注解的 required 属性为 false,找不到装配Null。 ⑤默认情况下，当 IOC 容器里存在多个类型兼容的 bean 时，Spring 会尝试匹配 bean的 id 值是否与变量名相同，如果相同则进行装配。如果 bean 的 id 值不相同,通过类型的自动装配将无法工作。此时可以在@Qualifier 解里提供 bean 的名称。Spring 甚至允许在方法的形参上标注@Qualifiter 注解以指定注入 bean 的名称。 ⑥@Autowired 注解也可以应用在数组类型的属性上，此时 Spring 将会把所有匹配的bean 进行自动装配。 ⑦@Autowired 注解也可以应用在集合属性上，此时 Spring 读取该集合的类型信息，然后自动装配所有与之兼容的 bean。 ⑧@Autowired 注解用在 java.util.Map 上时，若该 Map 的键值为 String，那么 Spring 将自动装配与值类型兼容的 bean 作为值，并以 bean 的 id 值作为键。 ⑨Spring自己的注解，最强大。 12345678910111213141516171819202122232425262728293031@Controllerpublic class BookServlet &#123; @Autowired private BookServiceImpl bookServiceImpl; public void show() &#123; System.out.println(\"BookServlet 调用业务层\"); bookServiceImpl.query(); &#125; &#125;@Servicepublic class BookServiceImpl implements BookService&#123; @Autowired private BookDaoImpl bookDaoImpl; @Override public void query() &#123; System.out.println(\"BookService 调用持久层\"); bookDaoImpl.sel(); &#125;&#125;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public void sel() &#123; System.out.println(\"BookDao\"); &#125;&#125;BookServlet bookServlet = applicationContext.getBean(\"bookServlet\",BookServlet.class);bookServlet.show(); 4.@Resource注解@Resource 注解要求提供一个 bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 bean 的名称。(javaee:java的标准,扩展性更强) 5.@Inject 注解@Inject 和@Autowired 注解一样也是按类型注入匹配的 bean，但没有 reqired 属性。 建议使用 @Autowired 注解。 2.6 可以使用的值2.6.1 字面值 可用字符串表示的值，可以通过 &lt;value&gt; 元素标签或 value 属性进行注入。 基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式 若字面值中包含特殊字符，可以使用&lt;![CDATA[]]&gt; 把字面值包裹起来。 2.6.2 null1&lt;property name=\"userName\"&gt;&lt;null/&gt;&lt;/property&gt; 2.6.3 引用外部已声明的bean​ 组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能。要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用。在 Bean 的配置文件中, 可以通过 &lt;ref&gt; 元素或 ref 属性为 Bean 的属性或构造器参数指定对 Bean 的引用。 1234567&lt;bean id=\"emp\" class=\"com.yyy.entity.Emp\"&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.yyy.entity.Dept\"&gt; &lt;property name=\"deptno\" value=\"10\"&gt;&lt;/property&gt; &lt;property name=\"dname\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.6.4 给bean的级联属性赋值123456789&lt;bean id=\"emp\" class=\"com.yyy.entity.Emp\"&gt; &lt;property name=\"empno\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"ename\" value=\"yyy\"&gt;&lt;/property&gt; &lt;property name=\"sal\" value=\"2000\"&gt;&lt;/property&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt; &lt;property name=\"dept.deptno\" value=\"20\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.yyy.entity.Dept\"&gt;&lt;/bean&gt; 2.6.5 内部bean​ 在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean。 ​ 当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 内部 Bean 声明直接包含在 &lt;property&gt; 或&lt;constructor-arg&gt; 元素里, 不需要设置任何 id 或 name 属性。内部 Bean 不能使用在任何其他地方。 1234567891011&lt;bean id=&quot;emp&quot; class=&quot;com.yyy.entity.Emp&quot;&gt; &lt;property name=&quot;empno&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;ename&quot; value=&quot;yyy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sal&quot; value=&quot;2000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean class=&quot;com.yyy.entity.Dept&quot;&gt; &lt;property name=&quot;deptno&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dname&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 2.7 集合属性2.7.1 数组与List​ 配置 java.util.List 类型的属性, 需要指定 &lt;list&gt; 标签, 在标签里包含一些元素. 这些标签可以通过 &lt;value&gt; 指定简单的常量值, 通过&lt;ref&gt; 指定对其他 Bean 的引用,通过&lt;bean&gt; 指定内置 Bean 定义,通过 &lt;null/&gt; 指定空元素, 甚至可以内嵌其他集合。数组的定义和 List 一样, 都使用 &lt;list&gt;,数组也可以使用&lt;array&gt;。 12345678910&lt;bean id=\"user\" class=\"com.yyy.entity.User\"&gt; &lt;property name=\"hobbies\"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 2.7.2 Set​ 配置 java.util.Set 需要使用&lt;set&gt;标签，定义的方法与 List 一样。 2.7.3 Map​ Java.util.Map 通过&lt;map&gt; 标签定义, &lt;map&gt; 标签里可以使用多个 &lt;entry&gt; 作为子标签。每个条目包含一个键和一个值. 必须在 &lt;key&gt; 标签里定义键因为键和值的类型没有限制, 所以可以自由地为它们指定 &lt;value&gt;, &lt;ref&gt;, &lt;bean&gt; 或 &lt;null&gt; 元素. 可以将 Map 的键和值作为 &lt;entry&gt; 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义。 123456789101112131415161718&lt;bean id=\"dept\" class=\"com.yyy.entity.Dept\"&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"1\" value=\"yyy\"&gt;&lt;/entry&gt; &lt;entry key=\"2\" value=\"root\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--另一种写法--&gt;&lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;1&lt;/value&gt; &lt;/key&gt; &lt;value&gt;yyy&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; 2.7.4 Properties​ 使用 &lt;props&gt; 定义 java.util.Properties, 该标签使用多个 &lt;prop&gt; 作为子标签. 每个 &lt;prop&gt; 标签必须定义 key 属性。 12345678&lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"driver\"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"url\"&gt;jdbc:mysql://localhost:3306/SSM&lt;/prop&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 2.7.5 使用util命名空间​ 使用基本的集合标签定义集合时, 不能将集合作为独立的 Bean 定义, 导致其他 Bean 无法引用该集合, 所以无法在不同 Bean 之间共享集合。可以使用 util 命名空间里的集合标签定义独立的集合 Bean。需要注意的是, 必须在 &lt;beans&gt; 根元素里添加 util 命名空间定义。 12345678910111213141516171819&lt;util:list id=\"list\"&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt;&lt;/util:list&gt;&lt;util:map id=\"map\"&gt; &lt;entry key=\"1\" value=\"唱\"&gt;&lt;/entry&gt; &lt;entry key=\"2\" value=\"跳\"&gt;&lt;/entry&gt; &lt;entry key=\"3\" value=\"篮球\"&gt;&lt;/entry&gt;&lt;/util:map&gt;&lt;util:properties id=\"properties\"&gt; &lt;prop key=\"driver\"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=\"url\"&gt;jdbc:mysql://localhost:3306/SSM&lt;/prop&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt;&lt;/util:properties&gt; 2.8 Bean的高级配置2.8.1 继承Bean的配置​ Spring 允许继承 bean 的配置, 被继承的 bean 称为父 bean,继承这个父 Bean 的 Bean 称为子 Bean。子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置;子 Bean 也可以覆盖从父 Bean 继承过来的配置。 12345678&lt;bean id=\"user1\" class=\"com.yyy.entity.User\"&gt; &lt;property name=\"userId\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"userName\" value=\"yinyuanyang\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"user2\" class=\"com.yyy.entity.User\" parent=\"user1\"&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; ​ 父 Bean 可以作为配置模板, 也可以作为 Bean 实例. 若只想把父 Bean 作为模板, 可以设置 &lt;bean&gt; 的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean。 2.8.2 依赖Bean的配置​ 有的时候创建一个 bean 的时候需要保证另外一个 bean 也被创建，这时我们称前面的 bean 对后面的 bean 有依赖。例如：要求创建 Employee 对象的时候必须创建 Department。这里需要注意的是依赖关系不等于引用关系，Employee 即使依赖 Department 也可以不引用它。 ​ Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，前置依赖的 Bean 会在本 Bean 实例化之前创建好。如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称。 12345&lt;bean id=\"emp03\" class=\"com.atguigu.parent.bean.Employee\" depends-on=\"dept\"&gt; &lt;property name=\"empId\" value=\"1003\"/&gt; &lt;property name=\"empName\" value=\"Kate\"/&gt; &lt;property name=\"age\" value=\"21\"/&gt; &lt;/bean&gt; 2.9 Bean的作用域​ 在 Spring 中，可以在&lt;bean&gt;元素的 scope 属性里设置 bean 的作用域，以决定这个 bean是单实例的还是多实例的。 ​ 默认情况下，Spring 只为每个在 IOC 容器里声明的 bean 创建唯一一个实例，整个 IOC 容器范围内都能共享该实例：所有后续的 getBean()调用和 bean 引用都将返回这个唯一的 bean 实例。该作用域被称为 singleton，它是所有 bean 的默认作用域。 2.9.1 singleton​ 在SpringIOC容器中仅存在一个Bean实例,Bean以单实例的方式存在,默认。 2.9.2 prototype​ 每次调用getBean()时都会返回一个新实例。 2.9.3 request​ 每次HTTP请求都会创建一个新的Bean。（没用） 2.9.4 session​ 同一个HTTP Session共享一个Bean。（没用） 2.9.5 总结当 bean 的作用域为单例时，Spring 会在 IOC 容器对象创建时就创建 bean 的对象实例。 当 bean 的作用域为 prototype 时，IOC 容器在获取 bean 的实例时创建 bean 的实例对象。 2.10 Bean的生命周期2.10.1 IOC容器中的生命周期方法1) Spring IOC 容器可以管理 bean 的生命周期，Spring 允许在 bean 生命周期内特定的时间点执行指定的任务。 2) Spring IOC 容器对 bean 的生命周期进行管理的过程： ​ ① 通过构造器或工厂方法创建 bean 实例 ​ ② 为 bean 的属性设置值和对其他 bean 的引用 ​ ③ 调用 bean 的初始化方法 ​ ④ bean 可以使用了 ​ ⑤ 当容器关闭时，调用 bean 的销毁方法 3) 在配置 bean 时，通过 init-method 和 destroy-method 属性为 bean 指定初始化和销毁方法。 2.10.2 创建Bean后置处理器​ Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。 ​ Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性。​ 对Bean 后置处理器而言, 需要实现 org.springframework.beans.factory.config.BeanPostProcessor 接口。在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法: 123456789101112131415161718import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor&#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return null; &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return null; &#125;&#125;//将后置处理器注册在Spring容器中&lt;bean id=\"myBeanPostPeocessor\" class=\"com.yyy.test.MyBeanPostProcessor\"&gt; &lt;/bean&gt; 2.10.3 添加Bean后置处理器后 Bean 的生命周期Spring IOC 容器对 Bean 的生命周期进行管理的过程: 1.通过构造器或工厂方法创建 Bean 实例 2.为 Bean 的属性设置值和对其他 Bean 的引用 3.将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法 4.调用 Bean 的初始化方法 5.将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法 6.Bean 可以使用了 7.当容器关闭时, 调用 Bean 的销毁方法 2.11 引用外部属性文件​ 当 bean 的配置信息逐渐增多时，查找和修改一些 bean 的配置信息就变得愈加困难。这 时可以将一部分信息提取到 bean 配置文件的外部，以 properties 格式的属性文件保存起来，同时在 bean 的配置文件中引用 properties 属性文件中的内容，从而实现一部分属性值在发生变化时仅修改 properties 属性文件即可。这种技术多用于连接数据库的基本信息的配置。 2.11.1 直接配置1234567&lt;!-- 直接配置 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/SSM\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; 2.11.2 使用外部属性文件1.创建properties属性文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/SSMjdbc.username=rootjdbc.password=123456 2.引入context命名空间3.指定properties属性文件的位置1&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; 4.从properties属性文件中引入属性值123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; 2.12 SpEL​ Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 ​ 语法类似于 EL：SpEL 使用 #{ } 作为定界符，所有在大框号中的字符都将被认为是 SpEL。SpEL 为 bean 的属性进行动态赋值提供了便利。通过 SpEL 可以实现：​ 1.通过 bean 的 id 对 bean 进行引用​ 2.调用方法以及引用对象中的属性​ 3.计算表达式的值​ 4.正则表达式的匹配 2.12.1 字面量1234567整数：&lt;property name=\"count\" value=\"#&#123;5&#125;\"/&gt;小数：&lt;property name=\"frequency\" value=\"#&#123;89.7&#125;\"/&gt;科学计数法：&lt;property name=\"capacity\" value=\"#&#123;1e4&#125;\"/&gt;String可以使用单引号或者双引号作为字符串的定界符号：&lt;property name=\"name\" value=\"#&#123;'Chuck'&#125;\"/&gt; 或 &lt;property name='name' value='#&#123;\"Chuck\"&#125;'/&gt;Boolean：&lt;property name=\"enabled\" value=\"#&#123;false&#125;\"/&gt; 2.12.2 引用其他的Bean、属性和方法123456789101112131415引用其他的Bean&lt;!--之前的写法--&gt;&lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt; &lt;!-- 使用SpEL --&gt;&lt;property name=\"dept\" value=\"#&#123;dept&#125;\"&gt;&lt;/property&gt;引用其他对象的非静态属性&lt;property name=\"deptName\" value=\"#&#123;dept.deptName&#125;\"&gt;&lt;/property&gt;调用非静态方法&lt;property name=\"dept\" value=\"#&#123;dept.toString()&#125;\"&gt;&lt;/property&gt;调用静态方法或静态属性(#&#123;T(类名).方法(属性)&#125;)通过 T() 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应的方法或属性。&lt;property name=\"circle\" value=\"#&#123;T(java.lang.Math).PI*20&#125;\"/&gt; 2.12.3 运算符1) 算术运算符：+、-、*、/、%、^ 2) 字符串连接：+ 3) 比较运算符：&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge 4) 逻辑运算符：and, or, not, | 5) 三目运算符：判断条件?判断结果为 true 时的取值:判断结果为 false 时的取值 6) 正则表达式：matches 第三章 AOP3.1 动态代理3.1.1代理设计模式的原理​ 使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 3.1.2 动态代理的方式1) 基于接口实现动态代理： JDK 动态代理 2) 基于继承实现动态代理： Cglib、Javassist 动态代理 3.2 AOP3.2.1 概述1) AOP(Aspect-Oriented Programming，面向切面编程)：是一种新的方法论，是对传统 OOP(Object-Oriented Programming，面向对象编程)的补充。 2) AOP 编程操作的主要对象是切面(aspect)，而切面模块化横切关注点。 3) 在应用 AOP 编程时，仍然需要定义公共功能，但可以明确的定义这个功能应用在哪里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的类里——这样的类我们通常称之为“切面”。 4) AOP 的好处： ① 每个事物逻辑位于一个位置，代码不分散，便于维护和升级。 ② 业务模块更简洁，只包含核心业务代码 ③ AOP 图解： 3.2.2 术语1.横切关注点从每个方法中抽取出来的同一类非核心业务。 2.切面(Aspect)封装横切关注点信息的类，每个关注点体现为一个通知方法。 3.通知(Advice) 切面必须要完成的各个具体工作。 4.目标(Target)被通知的对象 5.代理(Proxy)向目标对象应用通知之后创建的代理对象。 6.连接点(Joinpoint)横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。例如：类某个方法调用前、调用后、方法捕获到异常后等。 在应用程序中可以使用横纵两个坐标来定位一个具体的连接点。 *7. 切入点(pointcut) *定位连接点的方式。每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物。如果把连接点看作数据库中的记录，那么切入点就是查询条件——AOP 可以通过切入点定位到特定的连接点。切点通过 org.springframework.aop.Pointcut 接口进行描述,它使用类和方法作为连接点的查询条件。 3.3 AspectJ3.3.1 简介AspectJ：Java 社区里最完整最流行的 AOP 框架。 在 Spring2.0 以上版本中，可以使用基于 AspectJ 注解或基于 XML 配置的 AOP。 3.3.2 在 Spring 中启用 AspectJ 注解支持1.导入 JAR 包com.springsource.net.sf.cglib-2.2.0.jar com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aop-4.0.0.RELEASE.jar spring-aspects-4.0.0.RELEASE.jar 2. 引入 aop 名称空间3. 配置​ 当 Spring IOC 容器侦测到 bean 配置文件中的&lt;aop:aspectj-autoproxy&gt;元素时，会自动为与 AspectJ 切面匹配的 bean 创建代理。 3.3.3 用 AspectJ 注解声明切面1) 要在 Spring 中声明 AspectJ 切面，只需要在 IOC 容器中将切面声明为 bean 实例。 2) 当在 Spring IOC 容器中初始化 AspectJ 切面之后，Spring IOC 容器就会为那些与 AspectJ切面相匹配的 bean 创建代理。 3) 在 AspectJ 注解中，切面只是一个带有@Aspect 注解的 Java 类，它往往要包含很多通知。 4) 通知是标注有某种注解的简单的 Java 方法。 5) AspectJ 支持 5 种类型的通知注解： ① @Before：前置通知，在方法执行之前执行 ② @After：后置通知，在方法执行之后执行 ③ @AfterRunning：返回通知，在方法返回结果之后执行 ④ @AfterThrowing：异常通知，在方法抛出异常之后执行 ⑥ @Around：环绕通知，围绕着方法执行 3.4 切入点表达式3.4.1 作用通过表达式的方式定位一个或多个具体的连接点。 3.4.2 语法细节execution([权限修饰符] [返回值类型] [简单类名/全类名] [方法名]([参数列表])) 例子： execution(* com.atguigu.spring.ArithmeticCalculator.*(..)) 含义 ArithmeticCalculator 接口中声明的所有方法。 第一个“*”代表任意修饰符及任意返回值。 第二个“*”代表任意方法。 “..”匹配任意数量、任意类型的参数。 若目标类、接口与该切面类在同一个包中可以省略包名 在 AspectJ 中，切入点表达式可以通过 “&amp;&amp;”、“||”、“!”等操作符结合起来。 3.5 当前连接点细节3.5.1 概述​ 切入点表达式通常都会是从宏观上定位一组方法，和具体某个通知的注解结合起来就能够确定对应的连接点。那么就一个具体的连接点而言，我们可能会关心这个连接点的一些具体信息，例如：当前连接点所在方法的方法名、当前传入的参数值等等。这些信息都封装在 JoinPoint 接口的实例对象中。 3.5.2 JoinPoint12String methodName=joinPoint.getSignature().getName(); //方法名List&lt;Object&gt; args=Arrays.asList(joinPoint.getArgs()); //参数列表 3.6 通知3.6.1 概述1) 在具体的连接点上要执行的操作。 2) 一个切面可以包括一个或者多个通知。 3) 通知所使用的注解的值往往是切入点表达式。 1) 前置通知：在方法执行之前执行的通知 2) 使用@Before 注解 3.6.2 后置通知1) 后置通知：后置通知是在连接点完成之后执行的，即连接点返回结果或者抛出异常的时 候 2) 使用@After 注解 3.6.3 返回通知1) 返回通知：无论连接点是正常返回还是抛出异常，后置通知都会执行。如果只想在连接 点返回的时候记录日志，应使用返回通知代替后置通知。 2) 使用@AfterReturning 注解,在返回通知中访问连接点的返回值 ①在返回通知中，只要将 returning 属性添加到@AfterReturning 注解中，就可以访问连 接点的返回值。该属性的值即为用来传入返回值的参数名称 ②必须在通知方法的签名中添加一个同名参数。在运行时 Spring AOP 会通过这个参数 传递返回值 ③原始的切点表达式需要出现在 pointcut 属性中 5.3.5 异常通知1) 异常通知：只在连接点抛出异常时才执行异常通知 2) 将 throwing 属性添加到@AfterThrowing 注解中，也可以访问连接点抛出的异常。 Throwable 是所有错误和异常类的顶级父类，所以在异常通知方法可以捕获到任何错误 和异常。 3) 如果只对某种特殊的异常类型感兴趣，可以将参数声明为其他异常的参数类型。然后通 知就只在抛出这个类型及其子类的异常时才被执行 38 更多 Java –大数据 –前端 –python 人工智能资料下载，可访问百度：尚硅谷官网JAVAEE 课程系列 ————————————————————————————— 5.3.6 环绕通知1) 环绕通知是所有通知类型中功能最为强大的，能够全面地控制连接点，甚至可以控制是 否执行连接点。 2) 对于环绕通知来说，连接点的参数类型必须是 ProceedingJoinPoint。它是 JoinPoint 的 子接口，允许控制何时执行，是否执行连接点。 3) 在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed()方法来执行被代理的方法。 如果忘记这样做就会导致通知被执行了，但目标方法没有被执行。 4) 注意：环绕通知的方法需要返回目标方法执行之后的结果，即调用 joinPoint.proceed(); 的返回值，否则会出现空指针异常。","categories":[],"tags":[]},{"title":"Mysql数据库（基础）","slug":"Mysql数据库(基础篇)","date":"2019-10-25T13:52:16.000Z","updated":"2019-10-25T14:54:01.208Z","comments":true,"path":"2019/10/25/Mysql数据库(基础篇)/","link":"","permalink":"https://re-frain.github.io/2019/10/25/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/","excerpt":"","text":"数据库相关概念1、DB：数据库，保存一组有组织的数据的容器。​2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据，常见的DBMS为MySql,Oracle,SqlServer,DB2。。。​3、SQL:结构化查询语言，用于和DBMS通信的语言。 MySQL产品的介绍和安装MySQL服务的启动和停止​ 方式一：计算机——右击管理——服务​ 方式二：通过管理员身份运行​ net start 服务名（启动服务）​ net stop 服务名（停止服务） MySQL服务的登录和退出123456789方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码例如： mysql -u root -p123456退出：exit或ctrl+C MySQL的常见命令12345678910111213141516171819202122232425262728291.查看当前所有的数据库show databases;2.打开指定的库use 库名;3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名( 列名 列类型， ...);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V MySQL的语法规范​ 1.不区分大小写,但建议关键字大写，表名、列名小写。​ 2.每条命令最好用分号结尾。​ 3.每条命令根据需要，可以进行缩进或换行。 12单行注释：#注释文字 -- 注释文字 (注意中间要带有一个空格才能生效)多行注释：/* 注释文字 */ SQL的语言分类1.DQL（Data Query Language)：数据查询语言 select2.DML (Data Manipulate Language): 数据操作语言 insert 、update、delete3.DDL（Data Define Languge)：数据定义语言 create、drop、alter4.TCL （Transaction Control Language)：事务控制语言 commit、rollback、savepoint 5.DCL（Data Control Language)：数据控制语言 grant、revoke DQL语言的学习基础查询123#语法：查询表的所有数据: SELECT * FROM 表名; 查询表中指定字段的值: SELECT 字段1,字段2...字段n FROM 表名; 特点：①通过select查询完的结果 ,是一个虚拟的表格，不是真实存在。②要查询的东西可以是常量值、可以是表达式、可以是字段、可以是函数。 4 使用别名12345#给查询结果中的字段使用别名字段名 as 别名或者字段名 &quot;别名&quot;SELECT name as &quot;花名&quot; FROM flower; 注意: as可以省略不写，别名中没有特殊字符，双引号也可以省略不写。 去除重复1SELECT DISTINCT 字段1,字段2...字段n FROM 表名; 注意：去除重复的规则是按照行进行去除的,多行数据完全相同取其一,DISTINCT必须放在要查询字段的开头。 +号12345678910111213#仅仅只有一个功能:运算符#两个操作数为数值型，则做加法运算SELECT 100+90; -- 190#只要其中一方为字符型，试图将字符型数值转换成数值型 #1.如果转换成功,则继续做加法运算#2.如果转换失败,则将字符型数值转换为0SELECT &quot;100&quot;+90; -- 190SELECT &quot;Tom&quot;+90; -- 90#只要其中一方为null,则结果肯定为nullSELECT null+90; -- null concat实现拼接操作12345#使用方法 CONCAT(str1,str2...) SELECT CONCAT(1,3,4); 测试 -- 一个数字参数被转化为与之相等的二进制字符串格式SELECT CONCAT(id,&apos;,&apos;,name) &quot;编号,花名&quot; from flower; 注意:返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。 条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据。 12语法：select 要查询的字段|表达式|常量值|函数 from 表名 where 筛选条件; 一、条件表达式条件运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != 二、逻辑表达式逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false。 or (||)：两个条件只要有一个成立，结果为true，否则为false。 not (!)：如果条件成立，则not后为false，否则为true。 ​ 三、模糊查询 %： 代替0个或多个任意字符。 _ ：代替1个任意字符。 1234SELECT * From flower where name like &apos;_a%&apos;;#转义关键词 ESCAPESELECT * From flower where name like &apos;_\\_%&apos;;SELECT * From flower where name like &apos;_$_%&apos; ESCAPE &apos;$&apos;; 四、关键字 between and1234#包含两头的数据 [ , ]SELECT * From emp where sal &gt;=200 and sal&lt;=300;#等价与SELECT * From emp where sal between 200 and 300; 五、关键字 in含义:判断某字段的值是否属于in列表中的某一项。 123#格式in (目标值1，目标值2，...) -- in 中的内容只能为一个字段的值,目标值之间必须使用逗号分隔,并且括在括号中。SELECT * From emp where job in (&apos;Salesman&apos;,&apos;manager&apos;,&apos;analyst&apos;); 六、关键字 is null , is not null1234#格式 SELECT * FROM 表名 WHERE 字段名 is null; -- 字段值为NullSELECT * FROM 表名 WHERE 字段名 is not null; -- 字段值不为NullSELECT * FROM emp WHERE comm is not null; -- 字段值不为Null 注意: 不能使用=,&lt;&gt;来判断NULL值。 七、安全等于 &lt;=&gt;1SELECT * FROM flower WHERE production &lt;=&gt; null; is null : 仅仅可以判断NULL值，可读性高,建议使用。 &lt;=&gt; : 既可以判断NULL值,又可以判断普通数值，可读性较低。 排序查询123456#语法#单字段排序select 要查询的东西 from 表名 where 筛选条件 order by 排序的字段|表达式|函数|别名 [asc|desc]#多字段排序select 要查询的东西 from 表名 where 筛选条件 order by 字段名1 [asc|desc],字段名2 [asc|desc]... 注意: 1.asc代表的是升序,desc代表的是降序,如果不写,默认为升序。 2.order by 子句中可以支持单个字段,多个字段,表达式,函数,别名。 3.order by 子句一般是放在查询语句的最后面,limit子句除外。 常见函数一、单行函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#用法SELECT 函数名() FROM 表名 WHERE 筛选条件1、字符函数 concat 拼接 substr 截取子串 -- 注意：索引从1开始 upper 转换成大写 lower 转换成小写 trim 去前后指定的空格和字符 ltrim 去左边空格 rtrim 去右边空格 replace 替换 lpad 用指定的字符实现左填充指定长度 rpad 用指定的字符实现右填充指定长度 instr 返回子串第一次出现的索引 -- 如果找不到返回0 length 获取字节个数2、数学函数 round 四舍五入 rand 随机数 floor 向下取整 -- &lt;=该参数的最大整数 ceil 向上取整 -- &gt;=该参数的最小整数 mod 取余 truncate 截断 3、日期函数 now 当前系统日期+时间 curdate 当前系统日期 curtime 当前系统时间 str_to_date 将字符转换成日期 date_format 将日期转换成字符 DATEDIFF 求两个日期相差的天数 SELECT DATEDIFF(now(),&quot;1998-05-27&quot;) 4、流程控制函数 #if 处理双分支 -- if else的效果SELECT last_name,commission_pct,IF(commission_pct is null,&apos;没奖金,呵呵&apos;,&apos;有奖金,嘻嘻&apos;) 备注 FROM employees; #case语句 #1.类似 switch-case的效果 case 要判断的字段或表达式 when 常量1 then 要显示的值1或者语句1; when 常量2 then 要显示的值2或者语句2; ... else 要显示的值n或者语句n; end #例子 SELECT salary 原始工资,department_id, CASE department_id WHEN 30 THEN salary*1.1 WHEN 40 THEN salary*1.2 WHEN 50 THEN salary*1.3 ELSE salary END AS 新工资 FROM employees #2.类似 多重if case when 条件1 then 要显示的值1或者语句1; when 条件2 then 要显示的值2或者语句2; ... else 要显示的值n或者语句n; end #例子 SELECT salary , CASE WHEN salary&gt;20000 THEN &apos;A&apos; WHEN salary&gt;15000 THEN &apos;B&apos; WHEN salary&gt;10000 THEN &apos;C&apos; ELSE &apos;D&apos; END AS 工资级别 FROM employees 5、其他函数 version 版本 database 当前库 user 当前连接用户 md5(&apos;字符&apos;) 返回该字符的md5加密形式 datediff(大的日期，小的日期) 返回两个日期的时间差 ​ 二、分组函数12345sum 求和max 最大值min 最小值avg 平均值count 计算个数 特点：1、*sum,max,min,avg,count(字段名)都忽略null值，count( )不忽略null值。2、sum和 avg一般用于处理数值型；max、min、count可以处理任何数据类型。3、都可以搭配distinct使用，用于统计去重后的结果。4、count的参数可以支持：字段、常量值、* ，一般放1,建议使用 count(*)。 效率： MyISAM存储引擎下,count(*)的效率高。 InnoDB存储引擎下,count(*)和count(1)的效率差不多，比count(字段名)要高一些。 分组查询1234567891011121314151617#语法：#分组前的筛选select 查询的字段，分组函数from 表名[where 筛选条件]group by 分组的字段[order by 子句]#分组后的筛选 having 子句-- 查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资select MAX(salary),job_id from employees where commission_pct is not nullgroup by job_id having MAX(salart)&gt;12000;-- 按员工姓名的长度分组,查询每一组的员工个数，筛选员工个数&gt;5select count(*) c,LENGTH(last_name) len_name from employees group by len_name having c&gt;5;#group by,having后可以支持别名。 特点：1、支持按单个字段分组;也可以按多个字段分组,多个字段之间用逗号隔开,没有顺序要求;表达式或函数(用得较少)。2、和分组函数一同查询的字段最好是分组后的字段。3、分组筛选针对的表 位置 关键字分组前筛选： 原始表 group by的前面 where分组后筛选： 分组后的结果集 group by的后面 having 分组函数做条件肯定是放在having子句中。 4.查询列表必须特殊,要求是分组函数和group by后出现的字段。 多表连接查询一、分类按年代分类： sql92标准，sql99标准 按功能分类: 内连接：等值连接,非等值连接,自连接 外连接：左外连接,右外连接,全外连接 交叉连接 二、笛卡尔乘积表1有m行，表2有n行,结果为m*n行。解决办法：添加上有效的连接条件。 1select * from emp,dept; 三、sql92标准含义：1992年推出的sql语法。 仅仅支持内连接。 1234567891011121314#1.等值连接 先做笛卡尔积，然后筛选,筛选条件为等值筛选。select e.ename,e.job,d.dname from emp e,dept d where e.deptno = d.deptno;/*1.多表等值连接的结果为多表的交集部分。2.n表连接，至少需要n-1个连接条件。3.多表的顺序没有要求，一般需要为表起别名。*/#2.非等值连接select * from emp e,sqlgrade s where e.sal&gt;=s.losal and e.sal&lt;=s.hisal;#3.自连接-- 查询员工姓名,工作,薪资,及上级领导的姓名select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr=e2.empno; 四、sql99标准[推荐使用]含义：1999年推出的sql语法。支持：内连接,外连接(左外连接，右外连接),交叉连接 123456789#语法：select 查询列表from 表1 别名【inner|left [outer]|right [outer]|cross】join 表2 别名on 连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-- 内连接#1.等值连接select 查询列表from 表1 别名[inner] join 表2 别名on 连接条件[where 筛选条件]select e.ename,e.job,d.dname from emp einner join dept d on e.deptno = d.deptnowhere e.deptno=1001;/*1.inner可以省略。2.连接条件放在on后面,筛选条件放在where后面,提高分离性,便于阅读。*/#2.非等值连接select * from emp einner join sqlgrade s on e.sal&gt;=s.losal and e.sal&lt;=s.hisal;#3.自连接select e1.ename,e1.job,e1.sal,e2.ename from emp e1inner join emp e2 on e1.mgr=e2.empno;-- 外连接#应用场景:用于查询一个表中有，另一个表没有的记录。/*特点：1.外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的,则显示匹配的值。 如果从表中没有和它匹配的,则显示null。 外连接查询的结果=内连接+主表中有而从表没有的记录。2.左外连接：left join左边的是主表 右外连接：left join右边的是主表3.左外和右外交换两个表的顺序,可以实现同样的效果。*/#1.左外连接与右外连接-- 左外连接select e.*,d.* from emp eleft outer join dept don e.deptno = d.deptno;-- 右外连接select e.*,d.* from emp eright outer join dept don e.deptno = d.deptno;#2.交叉连接 本质就是笛卡尔积select e.*,d.* from emp ecross join dept don e.deptno=d.deptno; 五、sql92 与 sql99的比较 功能：sql99支持的较多。 可读性：sql99实现连接条件和筛选条件的分离,可读性较高。 推荐性: 建议使用sql99。 子查询含义： ​ 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询;在外面的查询语句，称为主查询或外查询。 分类： 按子查询出现的位置： 12345678910SELECT 后面： 仅仅支持标量子查询from 后面: 支持表子查询where或having后面: 标量子查询 (单行子查询) 列子查询 (多行子查询) 行子查询 (多列多行)exists 后面 (相关子查询) 表子查询 按结构集的行列数不同: 标量子查询（结果集只有一行一列） ​ 列子查询 （结果集只有一列多行） ​ 行子查询 （结果集有一行多列） ​ 表子查询 (结果集一般为多行多列） 特点： 1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： a、子查询的结果为一组值 b、子查询的结果为空 1234567891011121314151617181920# 标量子查询-- 查询工资比Tom高的员工信息select *form empwhere sal&gt;( select sal from emp where ename = &apos;Tom&apos;);-- 查询最低工资大于50号的最低工资的部门编号和其最低工资。select min(sal),deptnofrom emp group by deptnohaving min(sal)&gt;( select min(sal) from emp where deptno=50); ② 多行子查询 结果只有一个字段但是字段有n个值。 ​ 一般搭配多行操作符使用：any、all、in、not in。 ​ any: 任意 ​ all: 所有 ​ in：表示任意存在，相当于=any。 ​ not in :相当于&lt;&gt; all。 12345678910111213141516171819202122232425262728293031323334353637#关键字 any-- 查询工资高于任意一个CLERK的所有员工信息。select * from empwhere sal &gt; any( select sal from emp where job=&apos;CLERK&apos;);#关键词 all-- 查询工资高于所有SALESMAN的员工信息。select * from emp where sal &gt; all( select sal from emp where job=&apos;SALESMAN&apos;);#关键词 in-- 查询部门号20中同部门10的雇员工作一样的雇员信息。select * from empwhere job in ( select job from emp where deptno=10) and deptno =20;-- 等价于select * from empwhere job = any( select job from emp where deptno=10) and deptno =20; 行子查询 (使用频率少) ​ 结果集一行多列或者多行多列 1234567891011121314151617#查询员工编号最小并且工资最高的员工信息。select *from empwhere empno = ( select min(empno) from emp) and sal = ( select max(sal) from emp);-- 等价于select *from empwhere (empno,sal) = ( select min(empno),max(sal) from emp); from后面的子查询 12345678910#查询每个部门的平均工资的工资等级-- 将子查询结果充当一张表,要求必须起别名select avg_dep.*,s.gradefrom ( select avg(sal) avg,deptno from emp group by deptno) avg_depinner join salgrade son avg_dep.avg between losal and hisal; exists后面的子查询 （相关子查询） EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值true或false,结果为1或0。 语法: exists (完整的查询语句) 123456789101112131415#查询有员工的部门名select d.dname from dept dwhere exists ( select * from emp e where d.deptno =e.deptno );-- 等价于select d.dname from dept dwhere d.deptno in ( select deptno from emp ); 分页查询应用场景： 实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句。 语法： 1234567select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数; 特点： 1.起始条目索引从0开始。 2.limit子句放在查询语句的最后 3.公式：select * from 表 limit （page-1）*size,size每页显示条目数size要显示的页数 page 12345678910111213#查询前五条员工的信息select * from emp limit 0,5;select * from emp limit 5;#查询第11条-第25条select * from emp 10,15;#有奖金的员工信息,并且工资较高的前10名显示出来select * from empwhere comm is not nullorder by sal desclimit 0,10; 联合查询引入： union 联合、合并：将多条查询语句的结果合并成一个结果。 语法： 12345select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1、多条查询语句的查询的列数必须是一致的。2、多条查询语句的查询的列的类型几乎相同。3、union代表去重，union all代表不去重。 应用场景： 要查询的结果来自于多个表，且多个表没有直接的连接关系,但查询的信息一致时。 1234#查询中国用户中男性的信息以及外国用户中年男性的用户信息select id,cname,csex from t_ca where csex =&apos;男&apos;unionselect t_id,tname from t_ua where tGender=&apos;male&apos;; DML语言的学习插入12345#语法：-- 方式一 支持插入多行，支持子查询 insert into 表名(字段名，...) values(值1，...);-- 方式二 insert into 表名 set 列名1=值1,列名2=值2...; 特点： 1、字段类型和值类型一致或兼容，而且一一对应。2、可以为空的字段，可以不用插入值，或用null填充。3、不可以为空的字段，必须插入值。4、字段个数和值的个数必须一致。5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致。 123456#方式一支持插入多行insert into beautyvalues(1603,&apos;尹远洋&apos;,&apos;男&apos;,23),(1604,&apos;张三&apos;,&apos;男&apos;,21),(1605,&apos;李丽&apos;,&apos;女&apos;,18);#支持子查询insert into beauty(id,name,age) select 1603,&apos;尹远洋&apos;,23; 修改修改单表语法： 1update 表名 set 字段=新值,字段=新值 where 筛选条件; 修改多表语法： 123456789101112#sql92语法update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件;#sql99语法update 表1 别名1inner|left|right join 表2 别名2on 连接条件set 字段=新值，字段=新值where 筛选条件; 删除方式1：delete语句单表的删除： ★ 1delete from 表名 [where 筛选条件]; 多表的删除： 123456789101112#sql92语法 delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; #sql99语法 delete 别名1，别名2 from 表1 别名1 inner|left|right join 表2 别名2 on 连接条件 where 筛选条件; 方式2：truncate语句1truncate table 表名; 两种方式的区别【面试题】 1.truncate不能加where条件，而delete可以加where条件。 2.truncate的效率高一丢丢。 3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始；delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。 4.truncate删除没有返回值，delete删除有返回值。 4.truncate删除不能回滚，delete删除可以回滚。 DDL语言的学习库和表的管理库的管理12345678#创建库create database [if not exists] 库名;#修改库 -- 目前不能用了,不安全#更改库的字符集alter database 库名 character set 字符集;#删除库drop database [if exists] 库名; 表的管理123456789101112131415161718192021222324252627282930313233343536373839404142#创建表CREATE TABLE [IF NOT EXISTS] 表名( 列名 列的类型[(长度) 约束], 列名 列的类型[(长度) 约束], ...);CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME);#修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO] studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20);#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#删除表DROP TABLE [IF EXISTS] studentinfo;#表的复制-- 1.仅仅复制表的结构create table 表名 like 表名;-- 2.复制表的结构+数据create table 新表 select * from 旧表; ​ 常见的数据类型整型： tinyint、smallint、mediumint、int/Integer、bigint小数： 浮点型: float、double 定点型:dec(M,D)、decimal(M,D) ​ 特点： ​ 1.M：整数部位+小数部位 ​ D:小数部位 ​ 如果超过范围，则插入临界值。 ​ 2.M和D都可以省略，如果是decimal，则M默认为10,D默认为0。 ​ 如果是float和double,则会根据插入的数值的精度来决定精度。 ​ 3.定点型的精确度较高,如果要求插入数值的精度较高如货币运算等则考虑使用。 字符型： 较短的文本:char 、varchar 较长的文本:text、blob(较大的二进制) 写法 M的意思 特点 空间的耗费 效率 char char(M) 最大的字符数,可以省略,默认为1 固定长度的字符 比较耗费 高 varchar varchar(M) 最大的字符数,不可以省略 可变长度的字符 比较节省 低 其他： binary和varbinary用于保存较短的二进制。 enum用于保存枚举。 set用于保存集合。 日期型： 分类： ​ data:只保存日期 ​ time:只保存时间 ​ year:只保存年 ​ datetime:保存日期+时间 ​ timestamp:保存日期+时间 特点： 字节 范围 时区等的影响 datetime 8 1000-9999 不受 timestamp 4 1970-2038 受 Blob类型： ​ ·tinyblob:仅255个字符 ·blob:最大限制到65K字节 ·mediumblob:限制到16M字节 ·longblob:可达4GB 常见约束1234567NOT NULL:非空,用来保证该字段的值不能为空DEFAULT:默认,用于保证该字段有默认值UNIQUE:唯一,用于保证该字段的值具有唯一性,可以为空CHECK:检查约束 [mysql中不支持]PRIMARY KEY:主键,用于保证该字段的值具有唯一性,并且非空FOREIGN KEY:外键,用于限制两个表的关系,用于保证该字段的值必须来自于主表的关联列的值在从表添加外键约束,用于引用主表中某列的值 添加约束的时机： ​ 1.创建表时 ​ 2.修改表时 约束的添加分类： ​ 列级约束： ​ 六大约束语法上都支持,但是外键约束没有效果 ​ 表级约束： ​ 除了非空,默认,其他的都支持 12345create table 表名( 字段名 字段类型 列级约束, 字段名 字段类型, 表级约束); 列级约束 语法：直接在字段名和类型后面追加约束类型即可。 只支持:默认,非空,主键,唯一。 表级约束 支持：主键,外键,唯一 1234[constraint 约束名] 约束类型(字段名);constraint pk PRIMARY KEY(id), #主键约束UNIQUE(seat), #唯一键constraint fk_stuinfo_major FOREIGN KEY(majorid) references major(id) #外键约束 主键和唯一的区别: 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有一个 √，但不推荐 唯一 √ √ 可以有多个 √，但不推荐 外键： 1.要求在从表设置外键关系。 2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称没要求。 3.主表的关联列必须是一个key（一般是主键或者唯一)。 4.插入数据时,先插入主表,再插入从表。删除数据时,先删除从表,再删除主表。 修改表时添加约束 1.添加列级约束 1alter table 表名 modify column 字段名 字段类型 新约束; 2.添加表级约束 1alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用]; 1234567891011121314151617#添加非空约束alter table stuinfo modify column stuname varchar(20) not null;#添加默认约束alter table stuinfo modify column age int default 18;#添加主键-- 列级约束alter table stuinfo modify column id int primary key;-- 表级约束alter table stuinfo add primary key(id);#添加唯一-- 列级约束alter table stuinfo modify column seat int unique;-- 表级约束alter table stuinfo add unique(seat);#添加外键-- 表级约束alter table stuinfo add constraint fk_stuinfo_major foreign key(majorid) references major(id); 修改表时删除约束 12345678910#删除非空约束alter table stuinfo modify column stuname varchar(20) null;#删除默认约束alter table stuinfo modify column age int ;#删除主键alter table stuinfo drop primary key;#删除唯一alter table stuinfo drop index seat;#删除外键alter table stuinfo drop foreign key fk_stuinfo_major; 位置 支持的约束类型 是否可以起约束名 列级约束 列的后面 语法都支持，但外键没有效果 不可以 表级约束 所有列的下面 默认和非空不支持,其他支持 可以(主键没有效果) 标识列 又称为自增长列。含义：可以不用手动的插入值，系统提供默认的序列值。 特点: 1.标识列要求是一个key。 2.一个表至多一个标识列。 3.标识列的类型只能是数值型。 4.标识列可以通过set auto_increment_increment=数字；设置步长 可以通过手动插入值 ,设置起始。 1234create table user( id int primary key auto_increment, ...) 修改表时设置标识列: 1alter table user modify column id int primary key auto_increment; 删除表时设置标识列: 1alter table user modify column id int; 数据库事务特点(ACID):​ 原子性（Atomicity）：一个事务不可再分割,要么都执行要么都不执行。​ 一致性(Consistency)：一个事务保证数据的状态操作前和操作后保持一致。​ 隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰。​ 持久性(Durability)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。 事务的分类隐式事务，没有明显的开启和结束事务的标志。 比如insert、update、delete语句本身就是一个事务。 显式事务，具有明显的开启和结束事务的标志。 前提：必须先设置自动提交功能为禁用。 set autocommit=0; 12345678910111213#步骤1:开启事务set autocommit=0;start transaction; #可选的 #步骤2.编写事务的一组逻辑操作单元（多条sql语句） select insert update delete #步骤3.提交事务或回滚事务 commit; 提交事务 rollback; 回滚事务 使用到的关键字123456789101112131415set autocommit=0;start transaction;commit;rollback;savepoint 断点commit to 断点rollback to 断点#演示savepoint的使用set autocommit=0;start transaction;delete from account where id=25;savepoint a;-- 设置保持点adelete from account where id=28;rollback to a; -- 回滚到保持点a 事务的隔离级别事务并发问题如何发生当多个事务同时操作同一个数据库的相同数据时。 事务的并发问题有哪些1、脏读脏读是指并发过程中，一个事务处理过程里读取了另一个未提交的事务中的数据。 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下： 123update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’; 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。 2、不可重复读 不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。 3、幻读 幻读是事务非独立执行时发生的一种现象。例如事务T1查询整张表中有多少条记录，这时事务T2又对这个表中插入了一行数据。而操作事务T1的用户如果再查看整张表有多少行数据，会发现多出一行数据，其实这行是事务T2添加的，就好像产生幻觉一样，这就是发生了幻读。 不可重复读和脏读的区别是:脏读是某一事务读取了另一个事务未提交的脏数据。 不可重复读则是两次读取之间存在另一个事务提交的数据。 幻读和不可重复读区别是： 不可重复读的重点是修改（update），操作的是某一行数据，需要锁行。同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。 幻读的重点在于新增（insert）或者删除（delete），操作的是整张表，需要锁表。同样的条件, 第1次和第2次读出来的记录数不一样。 如何避免事务的并发问题通过设置事务的隔离级别:1、READ UNCOMMITTED（读未提交）2、READ COMMITTED（读已提交） 可以避免脏读3、REPEATABLE READ（可重复读） 可以避免脏读、不可重复读和一部分幻读 (默认)4、SERIALIZABLE (串行化) 可以避免脏读、不可重复读和幻读 设置隔离级别1set session|global transaction isolation level 隔离级别名; 查看隔离级别1select @@tx_isolation; 视图含义：理解成一张虚拟的表。 视图和表的区别： 使用方式 占用物理空间 视图 增删改查，一般不做增删改 create view 不占用，仅仅保存的是sql逻辑 表 增删改查 create table 占用 视图的好处： 1、sql语句提高重用性，简化复杂的sql操作，效率高。2、和表实现了分离，保护数据,提高了安全性。 视图的创建语法： 123CREATE VIEW 视图名 AS查询语句; 视图中数据增删改查12345678910111213#1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;#一般不更改视图里面的数据#2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);#3、修改视图的数据UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;#4、删除视图的数据DELETE FROM my_v4; 某些视图不能更新​ 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all​ 常量视图​ Select中包含子查询​ join​ from一个不能更新的视图​ where子句的子查询引用了from子句中的表 视图的更新12345678910#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees; 视图的删除1DROP VIEW test_v1,test_v2,test_v3; 视图的查看1234#方式1DESC test_v7;#方式2SHOW CREATE VIEW test_v7; 查询顺序FROM –&gt; ON –&gt; JOIN –&gt; Where –&gt; group by –&gt; having –&gt; select –&gt; distinct –&gt; order by –&gt; limit","categories":[],"tags":[]}]}